<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transcribe Panel</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    :root {

      --primary-color: #333333;
      --primary-dark: #1a1a1a;
      --primary-bg: #f2f2f2;
      --secondary-bg: #e6e6e6;
      --tertiary-bg: #d9d9d9;
      --highlight-bg: #cccccc;
      --text-primary: #1a1a1a;
      --text-secondary: #4d4d4d;
      --text-tertiary: #808080;
      --border-color: #b3b3b3;
      --highlight: #4d4d4d;
      --error: #8c1c1c;
      --success: #245a24;
      --warning: #8c680b;
      --transition: all 0.2s ease-in-out;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
      --radius: 8px;
      --radius-lg: 12px;
      --header-height: 64px;
      --sidebar-width: 260px;
    }

    .nova-theme {
      --primary-color: #10b981;
      --primary-dark: #059669;
      --primary-bg: #262a37;
      --secondary-bg: #1a1d26;
      --tertiary-bg: #141a1e;
      --highlight-bg: #059669;
      --text-primary: #f3f4f6;
      --text-secondary: #9ca3af;
      --text-tertiary: #6b7280;
      --border-color: #374151;
      --highlight: #10b981;
      --error: #ef4444;
      --success: #3e884e;
      --warning: #f59e0b;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .minty-theme {
      --primary-color: #ff6f61;
      --primary-dark: #ff6f61;
      --primary-bg: #e8f5e9;
      --secondary-bg: #c8e6c9;
      --tertiary-bg: #e6fae4;
      --highlight-bg: #dcedc8;
      --text-primary: #3e2723;
      --text-secondary: #5d4037;
      --text-tertiary: #9e8780;
      --border-color: #b2d3ad;
      --highlight: #ff6f61;
      --error: #e03939;
      --success: #81c784;
      --warning: #f59836;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1);
    }

        .Toffee-theme {
      --primary-color: #c98900;
      --primary-dark: #c59734;
      --primary-bg: #1a1a1a;
      --secondary-bg: #121212;
      --tertiary-bg: #131210;
      --highlight-bg: #333333;
      --text-primary: #c7bda8;
      --text-secondary: #c0c0c0;
      --text-tertiary: #909090;
      --border-color: #404040;
      --highlight: #ffae00;
      --error: #b83434;
      --success: #4caf50;
      --warning: #ffc107;
      --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2), 0 2px 4px -1px rgba(0, 0, 0, 0.1);
    }

    .header, .sidebar, .card, .input-panel, .settings-panel, .transcript-panel, .dropzone, .file-item, .btn, .toast, input, textarea, .api-key-input, .transcript-segment, .tab-btn {
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Inter', sans-serif; background-color: var(--primary-bg); color: var(--text-primary); line-height: 1.5;
      transition: background-color 0.3s ease, color 0.3s ease; overflow-x: hidden;
    }
    h1, h2, h3, h4, h5, h6 { font-weight: 600; line-height: 1.3; }
    h1 { font-size: 2rem;}
    h2 { font-size: 1.5rem;}
    h3 { font-size: 1.25rem; margin-bottom: 0.5rem; }
    h3 { font-size: 1rem; margin-bottom: 0.5rem; }
    a { color: var(--primary-dark); text-decoration: none; transition: var(--transition); }
    a:hover { color: var(--primary-color); }
    .app-container { display: grid; grid-template-columns: var(--sidebar-width) 1fr; grid-template-rows: var(--header-height) 1fr; grid-template-areas: "header header" "sidebar main"; min-height: 100vh; }
    .header { grid-area: header; display: flex; align-items: center; padding: 0 1.5rem; background-color: var(--secondary-bg); border-bottom: 1px solid var(--border-color); position: relative; overflow: hidden; z-index: 10; transition: transform 0.3s ease-in-out; height: var(--header-height); }
    .header.header-hidden { transform: translateY(-100%); }
    .header.header-visible { transform: translateY(0); }
    .logo { display: flex; align-items: center; gap: 0.5rem; color: var(--text-primary); font-family: 'Merriweather', serif; margin: 0 auto; }
    .logo i { color: var(--primary-color); font-size: 2rem; }
    .logo h1 { margin: 0; font-size: 1.5rem; font-weight: 700; }
    .logo a { display: flex; align-items: center; gap: 0.5rem; text-decoration: none; color: inherit; cursor: pointer; }
    .logo .highlight-text {
      transition: color 0.3s ease-in-out;
      color: inherit;
    }
    .logo a:hover .highlight-text {
      color: var(--primary-color);
      animation: fadeInOut 1.5s ease-in-out;
    }

    @keyframes fadeInOut {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    .header-buttons {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .btn-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background-color: var(--tertiary-bg);
      color: var(--text-primary);
      cursor: pointer;
      transition: var(--transition);
    }
    
    .btn-icon:hover {
      background-color: var(--highlight-bg);
      color: var(--primary-color);
    }
    
    .btn-icon i {
      font-size: 1.25rem;
    }
    
    .sidebar-hidden {
      display: none;
    }
    
    .header-actions { display: flex; align-items: center; gap: 1rem; position: absolute; right: 1.5rem; }
    .header-actions button { font-size: 1rem; }
    .sidebar { grid-area: sidebar; background-color: var(--secondary-bg); border-right: 1px solid var(--border-color); padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; height: calc(100vh - var(--header-height)); }
    .info-section { margin-bottom: 1.5rem; }
    .info-section:last-child { margin-top: auto; }
    
    /* Compact Modal Styling */
    .modal-body .info-section { margin-right: 1rem; margin-bottom: 1rem; }
    .modal-body .info-section ul { margin-bottom: 0rem; margin-top: 0.5rem; }
    .modal-body .info-section h2 { font-size: 1rem; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border-color); }
    .modal-body .info-section h3 { font-size: 0.95rem; color: var(--primary-color); display: flex; align-items: center; gap: 0.4rem; position: relative; margin-bottom: 0.4rem; }
    .modal-body .info-section h3 .model-icon { color: inherit; font-size: 0.95rem; }
    .modal-body .info-section h3 .ri-external-link-line { position: absolute; right: 0; font-size: 0.8rem; }
    .modal-body .info-section p { color: var(--text-secondary); font-size: 0.85rem; line-height: 1.4; margin-bottom: 0.5rem; }
    .modal-body .info-section li { color: var(--text-secondary); font-size: 0.85rem; line-height: 1.4; margin-left: 1.5em; margin-bottom: 0.2rem; }
    
    /* Unified API Setup Section */
    .api-setup-unified {
      background-color: var(--tertiary-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      padding: 1rem;
    }
    .api-setup-unified h3 {
      margin-bottom: 0.75rem;
      font-size: 0.95rem;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .api-providers {
      display: grid;
      gap: 1rem;
    }
    .api-provider h4 {
      font-size: 0.85rem;
      color: var(--text-primary);
      margin-bottom: 0.4rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .api-provider h4 svg {
      fill: currentColor;
    }
    .api-provider ol {
      margin: 0;
      padding-left: 1rem;
      font-size: 0.8rem;
      color: var(--text-secondary);
    }
    .api-provider li {
      margin-bottom: 0.2rem;
      line-height: 1.3;
    }
    .api-provider a {
      color: var(--primary-color);
      text-decoration: none;
    }
    .api-provider a:hover {
      text-decoration: underline;
    }

    /* Default info-section styling (for sidebar) */
    .notification-hint { color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.5rem; line-height: 1.4; }
    .info-section h2 { font-size: 1.1rem; margin-bottom: 1rem; border-bottom: 1px solid var(--border-color); }
    .info-section h3 { font-size: 1.1rem; color: var(--primary-color); display: flex; align-items: center; gap: 0.5rem; position: relative; }
    .info-section h3 .model-icon { color: inherit; font-size: 1.1rem; }
    .info-section h3 .ri-external-link-line { position: absolute; right: 0; }
    .info-section p { color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6; }
    .info-section li { color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6; margin-left: 2em; }
    .stats { display: flex; flex-direction: column; gap: 1rem; }
    .stat-item { display: flex; justify-content: space-between; align-items: center; }
    .stat-label { font-size: 0.9rem; color: var(--text-secondary); }
    .stat-value { font-weight: 600; font-size: 1.1rem; }
    .stats-loading { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: var(--text-secondary); }
    .stats-loading svg { color: var(--primary-color); margin-top: 0.25rem; }
    @keyframes statsSpinner { to { transform: rotate(360deg); } }
    .main-container { grid-area: main; display: flex; height: calc(100vh - var(--header-height)); background-color: var(--primary-bg); backdrop-filter: blur(5px); }
    .input-panel { flex: 0 0 460px; max-width: 460px; height: 100%; overflow-y: auto; padding: 1.5rem; border-right: 1px solid var(--border-color); }
    .input-panel-content { display: flex; gap: 1.5rem; margin-bottom: 1.5rem; }
    .files-column { flex: 1; min-width: 0; display: flex; flex-direction: column; }
    .settings-column { flex: 1; min-width: 0; display: flex; flex-direction: column; height: 100%; }
    .output-panel { flex: 1; height: 100%; overflow-y: auto; padding: 1.5rem; display: flex; flex-direction: row; gap: 1.5rem; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--secondary-bg); }
    ::-webkit-scrollbar-thumb { background-color: var(--border-color); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background-color: var(--text-tertiary); }
    .dropzone { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; padding: 1rem; background-color: var(--secondary-bg); border: 2px dashed var(--border-color); border-radius: var(--radius); cursor: pointer; transition: var(--transition); margin-bottom: 1.5rem; }
    .dropzone:hover, .dropzone.dragover { border-color: var(--primary-color); background-color: var(--tertiary-bg); }
    .dropzone i { font-size: 2.5rem; color: var(--primary-color); }
    .dropzone-title { font-weight: 600; margin-bottom: 0.5rem; }
    .dropzone input[type="file"] { display: none; }
    
    /* Condensed dropzone when files are present */
    .dropzone.condensed { flex-direction: row; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
    .dropzone.condensed i { font-size: 1.75rem; margin-right: 0; }
    .dropzone.condensed .dropzone-title { margin-bottom: 0; font-size: 0.9rem; }
    .dropzone.condensed .dropzone-left { display: flex; align-items: center; gap: 0.5rem; }
    .dropzone.condensed .dropzone-buttons { display: flex; gap: 0.5rem; }
    .dropzone.condensed .btn { padding: 0.25rem 0.5rem; font-size: 0.85rem; }
    .dropzone.condensed #exampleFileBtn, .dropzone.condensed .button-separator { display: none; }
    
    .dropzone:not(.condensed) .dropzone-left { display: contents; }
    .dropzone-buttons { display: flex; gap: 0.75rem; align-items: center; }
    .button-separator { color: var(--text-tertiary); font-size: 0.9rem; font-weight: 500; }
    .file-list-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; }
    .file-list-title { font-weight: 600; display: flex; align-items: center; gap: 0.5rem; }
    .file-list-title i { color: var(--primary-color); }
    .file-count { background-color: var(--tertiary-bg); color: var(--text-secondary); padding: 0.25rem 0.5rem; border-radius: 1rem; font-size: 0.85rem; }
    .file-list-actions { display: flex; gap: 0.5rem; }
    .file-item { display: flex; align-items: center; padding: 0.75rem 1rem; background-color: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); margin-bottom: 0.5rem; transition: var(--transition); cursor: pointer; position: relative; }
    .file-item:hover { background-color: var(--tertiary-bg); }
    .file-item.selected { border-left: 3px solid var(--primary-color); background-color: var(--tertiary-bg); }
    .file-item.completed::after { content: ""; position: absolute; top: 0; right: 0; width: 6px; height: 100%; background-color: var(--success); border-top-right-radius: var(--radius); border-bottom-right-radius: var(--radius); }
    .file-item.processing::after { content: ""; position: absolute; top: 0; right: 0; width: 6px; height: 100%; background-color: var(--warning); animation: pulse 2s infinite; border-top-right-radius: var(--radius); border-bottom-right-radius: var(--radius); }
    .file-item.failed { border-left: 3px solid var(--error) !important; }
    @keyframes pulse { 0%, 100% { opacity: 0.6; } 50% { opacity: 1; } }
    .file-checkbox { margin-right: 0.75rem; display: flex; align-items: center; }
    .file-checkbox input[type="checkbox"] { display: none; }
    .file-checkbox label { width: 18px; height: 18px; border: 2px solid var(--border-color); border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: var(--transition); cursor: auto; }
    .file-checkbox input[type="checkbox"]:checked + label { background-color: var(--primary-color); border-color: var(--primary-color); }
    .file-checkbox input[type="checkbox"]:checked + label i { display: block; color: white; font-size: 12px; }
    .file-checkbox label i { display: none; }
    .file-icon { background-color: var(--tertiary-bg); color: var(--primary-color); width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 6px; margin-right: 0.75rem; }
    .file-info { flex: 1; min-width: 0; }
    .file-name { font-weight: 500; margin-bottom: 0.25rem; }
    .file-meta { display: flex; align-items: center; gap: 1rem; font-size: 0.85rem; color: var(--text-tertiary); }
    .file-meta span { display: flex; align-items: center; gap: 0.25rem; }
    .file-status { padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem; text-transform: uppercase; font-weight: 600; }
    .file-status.idle { background-color: var(--tertiary-bg); color: var(--text-secondary); }
    .file-status.processing { background-color: var(--border-color); color: var(--warning); }
    .file-status.completed { background-color: var(--border-color); color: var(--success); }
    .file-status.failed { background-color: var(--border-color); color: var(--error); }
    .file-models { display: flex; gap: 0.5rem; margin-left: auto; }
    .file-model { background-color: var(--success); color: var(--tertiary-bg); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
    .file-actions { display: flex; gap: 0.5rem; margin-left: 0.75rem; }
    .file-actions button { background: none; border: none; color: var(--border-color); font-size: 1rem; cursor: pointer; transition: var(--transition); padding: 0.25rem; }
    .file-actions button:hover { color: var(--text-primary); }

    /* Settings Panel */
    .settings-panel { background-color: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); padding: 1.5rem; flex: 1; overflow-y: auto; }
    .settings-content { background-color: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); padding: 1.5rem; margin-top: 1rem; flex: 1; overflow-y: auto; }
    .settings-title { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 1rem; }
    .settings-title i { color: var(--primary-color); }
    .model-options { margin-bottom: 0.5rem; }
    .options-title { display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem; }
    .options-title i { color: var(--primary-color); }
    .options-title h3, .options-title h4 { margin: 0; font-size: 0.9rem; font-weight: 500; }
    .model-tabs-header { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 1.5rem; }
    .model-tab-button { flex: 1; padding: 0.75rem 1rem; background: none; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); transition: var(--transition); position: relative; }
    .model-tab-button:hover { color: var(--text-primary); background: var(--secondary-bg); }
    .model-tab-button.active { color: var(--primary-color); background: var(--tertiary-bg); border: 1px solid var(--border-color); border-bottom: 1px solid var(--primary-bg); border-radius: var(--radius) var(--radius) 0 0; margin-bottom: -1px; }
    .model-tab-button.disabled { opacity: 0.5; cursor: not-allowed; }
    .model-tab-button.disabled:hover { color: var(--text-secondary); background: none; }
    .model-tab-content { display: none; }
    .model-tab-content.active { display: block; }
    .model-tab-content.disabled .model-option { opacity: 0.4; pointer-events: none; }
    .model-tab-content.disabled .model-option label { cursor: not-allowed; background-color: var(--secondary-bg); }
    .local-model-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem; grid-auto-rows: 1fr; }
    .cloud-model-grid { display: grid; grid-template-columns: 1fr; gap: 0.5rem; }
    .model-option { position: relative; }
    .model-option input { position: absolute; opacity: 0; width: 0; height: 0; }
    .model-option label { display: flex; flex-direction: row; align-items: center; justify-content: space-between; text-align: left; padding: 0.75rem 1rem; background-color: var(--primary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); cursor: pointer; transition: var(--transition); height: 100%; }
    .cloud-model-grid .model-option label, .local-model-grid .model-option label { padding: 0.25rem 0.75rem; }
    .theme-model-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
    .theme-model-grid .model-option label { padding: 0.25rem 0.75rem; justify-content: center; font-size: 0.85rem; }
    .theme-model-grid .model-option input:checked + label { color: var(--primary-color); font-weight: bold; }
    
    .model-option label:hover { background-color: var(--secondary-bg); }
    .model-option input:checked + label { background-color: var(--tertiary-bg); border-color: var(--primary-color); }
    .model-option input:checked + label:hover { background-color: var(--tertiary-bg); }
    .model-option input:checked + label .model-name { color: var(--primary-dark); font-weight: 700; }
    .model-left { display: flex; align-items: center; gap: 0.5rem; }
    .model-icon { font-size: 1.25rem; color: var(--text-secondary); margin-bottom: 0; }
    .model-option input:checked + label .model-icon { color: var(--primary-color); }
    .model-name { font-weight: 600; font-size: 0.9rem; }
    .model-desc { font-size: 0.75rem; color: var(--text-tertiary); text-align: right; }
    .model-done-badge { position: absolute; top: -6px; right: -6px; background-color: var(--success); color: white; font-size: 0.7rem; font-weight: 600; padding: 0.15rem 0.3rem; border-radius: 3px; }
    .api-key-section { margin-bottom: 1.5rem; display: none; order: 1; }
    .api-key-section.active { display: block; }
    .api-key-input { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
    .api-key-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; margin-bottom: 0.5rem; }
    .api-key-header h4 { font-size: 0.9rem; font-weight: 500; color: var(--text-secondary); margin: 0; }
    .api-key-toggle { background: none; border: none; color: var(--text-tertiary); cursor: pointer; font-size: 1.2rem; padding: 0.25rem; line-height: 1; }
    .api-key-toggle:hover { color: var(--text-primary); }
    .api-key-instructions { display: none; margin-top: 0.5rem; padding: 0.75rem 1rem; background-color: rgba(0, 0, 0, 0.03); border: 1px solid var(--border-color); border-radius: var(--radius-sm, 6px); font-size: 0.85rem; color: var(--text-secondary); }
    .api-help-text { font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem; line-height: 1.4; }
    .api-key-instructions h4 { font-size: 0.9rem; font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; }
    .api-key-instructions ol { margin-left: 1.25rem; padding-left: 0.5rem; line-height: 1.6; }
    .api-key-instructions li { margin-bottom: 0.25rem; }
    .api-key-instructions a { color: var(--primary-dark); text-decoration: underline; }
    .api-key-instructions a:hover { color: var(--primary-color); }
    .api-key-instructions .small-note { margin-top: 0.75rem; font-size: 0.8rem; font-style: italic; color: var(--text-tertiary); }

    /* Progress Bar */
    .progress-container { height: 6px; background-color: var(--tertiary-bg); border-radius: 1rem; overflow: hidden; margin-top: 1rem; display: none; }
    .progress-container.active { display: block; }
    .progress-bar { height: 100%; background-color: var(--primary-color); border-radius: 1rem; width: 0; transition: width 0.3s ease; animation: pulse 2s infinite; }
    .progress-info { display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem; }

    /* Preview Panel */
    .preview-panel { background-color: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); padding: 1.5rem; flex: 0 0 500px; max-width: 500px; height: fit-content; }
    .preview-title { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; }
    .preview-title-text { display: flex; align-items: center; gap: 0.5rem; font-weight: 600; }
    .preview-title-text i { color: var(--primary-color); }
    .preview-options { display: flex; gap: 0.5rem; }
    .preview-options .btn.active { background-color: var(--tertiary-bg); color: var(--primary-color); font-weight: 600; border: 1px solid var(--primary-color); padding: 0.3rem 0.7rem; }
    .preview-player { width: 100%; max-height: 300px; background-color: var(--tertiary-bg); border-radius: var(--radius); margin-bottom: 1rem; display: none; }
    .waveform-container { background-color: var(--primary-bg); border-radius: var(--radius); border: 1px solid var(--border-color); padding: 0.5rem 1rem; margin-bottom: 1rem; display: none; align-items: center; gap: 1rem; }
    .wave-wrapper { flex: 1; height: 60px; position: relative; }
    .time-display { display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--text-secondary); position: absolute; bottom: -2.5em; left: 0; right: 0; }
    .controls { display: flex; justify-content: center; }
    .play-btn { width: 40px; height: 40px; border-radius: 50%; background-color: var(--primary-color); border: none; color: white; font-size: 1.1rem; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: var(--transition); }
    .play-btn:hover { background-color: var(--primary-dark); }

    /* Transcript Panel */
    .transcript-panel { background-color: var(--secondary-bg); border-radius: var(--radius); overflow: hidden; display: flex; flex-direction: column; flex: 1; margin-bottom: 0; border: 1px solid var(--border-color); position: relative; }
    .transcript-header { border-bottom: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 1rem 1.5rem; }
    .transcript-title { display: flex; align-items: center; justify-content: space-between; gap: 0.5rem; font-weight: 600; margin-bottom: 1rem; }
    .transcript-title-content { display: flex; align-items: center; gap: 0.5rem; }
    .transcript-controls { display: flex; justify-content: space-between; align-items: flex-end; }
    .transcript-title i { color: var(--primary-color); }
    .transcript-tabs { display: flex; flex-wrap: wrap; gap: 0.25rem; }
    .transcript-actions { display: flex; flex-wrap: wrap; gap: 0.25rem; justify-content: flex-end; }
    
    .zoom-group { display: flex; gap: 0.25rem; margin-right: 0.5rem; }
    .upload-download-group { display: flex; gap: 0.25rem; }

    .download-dropdown {
      position: relative;
      display: inline-block;
    }

    .download-options {
      position: absolute;
      top: 100%;
      right: 0;
      background-color: var(--secondary-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      min-width: 200px;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s ease;
    }

    .download-dropdown:hover .download-options {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .download-dropdown.disabled:hover .download-options {
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
    }

    .download-option {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      transition: background-color 0.2s ease;
      border-bottom: 1px solid var(--tertiary-bg);
      font-size: 0.95rem;
      color: var(--text-primary);
      min-height: 2.5rem;
    }

    .download-option::before {
      content: "";
      width: 1.25rem;
      height: 1.25rem;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none'%3e%3cpath d='M3 19h18v2H3v-2zM13 9h7l-8 8-8-8h7V1h2v8z' fill='%236b7280'/%3e%3c/svg%3e");
      background-size: contain;
      background-repeat: no-repeat;
      opacity: 0.7;
      flex-shrink: 0;
    }

    .download-option:last-child {
      border-bottom: none;
    }

    .download-option:hover {
      background-color: var(--primary-color);
    }

    .download-option:first-child {
      border-radius: var(--radius) var(--radius) 0 0;
    }

    .download-option:last-child {
      border-radius: 0 0 var(--radius) var(--radius);
    }

    .transcript-dropdown {
      background-color: var(--secondary-bg);
      border: 1px solid var(--border-color);
      color: var(--text-primary);
      font-size: 0.9rem;
      padding: 0.3rem 0.6rem 0.3rem 1rem;
      border-radius: var(--radius);
      cursor: pointer;
      transition: var(--transition);
      padding-right: 2rem;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 0.5rem center;
      background-repeat: no-repeat;
      background-size: 1.5em 1.5em;
      appearance: none;
    }
    .transcript-dropdown:hover {
      background-color: var(--tertiary-bg);
      border-color: var(--primary-color);
    }
    .transcript-dropdown:focus {
      outline: none;
      border-color: var(--primary-color);
      background-color: var(--tertiary-bg);
    }
    .transcript-content { flex: 1; overflow-y: auto; padding: 1.5rem; position: relative; background-color: var(--primary-bg); }
    .transcript-segment { padding: 0.75rem 1rem; background-color: var(--secondary-bg); border-radius: var(--radius); margin-bottom: 0.75rem; transition: var(--transition); position: relative; }
    .transcript-segment:hover { background-color: var(--tertiary-bg); }
    .seek-btn { position: absolute; top: 0.5rem; right: 0.5rem; opacity: 0; transition: opacity 0.2s ease-in-out; z-index: 10; }
    .transcript-segment:hover .seek-btn { opacity: 1; }
    
    .transcript-segment.highlighted { background-color: var(--tertiary-bg); border-left: 3px solid var(--primary-color); }
    .segment-time { font-size: 0.75rem; color: var(--text-tertiary); margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.25rem; }
    .segment-text { line-height: 1.5; }
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        background-color: var(--primary-bg);
        opacity: 0.94;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 5;
    }
    .loading-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; z-index: 10; }
    .loading-text { color: var(--text-primary); font-weight: 500; font-size: 1.2rem; text-align: center; }
    .loading-bars { display: inline-flex; margin-top: 0.5rem; color: var(--primary-color); }
    .loading-bars svg { transform: rotate(90deg); }
    .loading-bars span { width: 6px; height: 6px; background-color: var(--primary-color); border-radius: 50%; margin: 0 3px; animation: dots 1.5s infinite; }
    .loading-bars span:nth-child(2) { animation-delay: 0.2s; }
    .loading-bars span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes dots { 0%, 100% { opacity: 0.2; transform: scale(0.8); } 50% { opacity: 1; transform: scale(1.2); } }
    .typewriter-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
    .typewriter-letter {
        position: absolute;
        font-family: monospace;
        color: var(--primary-color);
        opacity: 0;
        animation: randomFadeBg 3.5s ease-in-out forwards;
        font-size: 20px;
    }
    @keyframes randomFadeBg {
        0% { opacity: 0; transform: scale(0.8); }
        40% { opacity: 0.5; transform: scale(1); }
        100% { opacity: 0; transform: scale(1.2); }
    }

    /* Buttons & Forms */
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.5rem 1rem; font-size: 0.9rem; font-weight: 500; border-radius: var(--radius); cursor: pointer; transition: var(--transition); border: 1px solid var(--border-color); color: var(--text-primary); background-color: var(--primary-bg); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn i { font-size: 1.1rem; }
    .btn-sm { padding: 0.35rem 0.75rem; font-size: 0.8rem; }
    .btn-primary { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
    .btn-primary:hover:not(:disabled) { background-color: var(--primary-dark); border-color: var(--primary-dark); }
    .btn-secondary { background-color: var(--primary-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
    .btn-secondary:hover:not(:disabled) { background-color: var(--highlight-bg); }
    .btn-danger { background-color: var(--error); color: white; border-color: var(--error); }
    .btn-danger:hover:not(:disabled) { background-color: #6b1616; border-color: #6b1616; }
    .btn-ghost { background-color: transparent; color: var(--text-secondary); border: none; }
    .btn-ghost:hover:not(:disabled) { background-color: var(--tertiary-bg); color: var(--text-primary); }
    .btn-icon { padding: 0.5rem; border-radius: 50%; }
    .btn-large { padding: 0.75rem 1.5rem; font-size: 1.1rem; font-weight: 600; }
    .btn-danger-outline { border-color: var(--error); }
    .btn-danger-outline:hover:not(:disabled) { background-color: var(--error); color: white; border-color: var(--error); }
    .input { background-color: var(--primary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); padding: 0.5rem 1rem; font-size: 0.9rem; color: var(--text-primary); transition: var(--transition); width: 100%; }
    .input:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(51, 51, 51, 0.1); }
    .tab-btn { background: none; border: 1px solid transparent; color: var(--text-secondary); font-size: 0.9rem; font-weight: 500; padding: 0.3rem 0.6rem; border-radius: var(--radius); cursor: pointer; transition: var(--transition); margin-bottom: 0.25rem; }
    .tab-btn:hover:not(.active) { color: var(--text-primary); background-color: var(--tertiary-bg); }
    .tab-btn.active { color: var(--primary-dark); background-color: var(--tertiary-bg); font-weight: 600; border-color: var(--primary-color); }
    .checkbox-container { display: flex; align-items: center; gap: 0.5rem; cursor: pointer; }
    .checkbox-container input { display: none; }
    .checkbox-custom { width: 18px; height: 18px; border: 2px solid var(--border-color); border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: var(--transition); }
    .checkbox-container input:checked + .checkbox-custom { background-color: var(--primary-color); border-color: var(--primary-color); }
    .checkbox-container input:checked + .checkbox-custom i { display: block; }
    .checkbox-custom i { color: white; font-size: 12px; display: none; }
    .checkbox-label { font-size: 0.9rem; user-select: none; }

    /* Toast Messages */
    .toast-container { position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; flex-direction: column; gap: 10px; }
    .toast { padding: 1rem; border-radius: var(--radius); background-color: var(--secondary-bg); box-shadow: var(--shadow); display: flex; align-items: center; gap: 0.75rem; min-width: 300px; max-width: 400px; animation: slideIn 0.3s ease, fadeOut 0.5s ease 2.5s forwards; }
    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; transform: translateY(-10px); } }
    .toast-icon { display: flex; align-items: center; justify-content: center; width: 28px; height: 28px; border-radius: 50%; font-size: 1rem; }
    .toast-info .toast-icon { background-color: var(--tertiary-bg); color: var(--highlight); }
    .toast-success .toast-icon { background-color: var(--tertiary-bg); color: var(--success); }
    .toast-error .toast-icon { background-color: var(--tertiary-bg); color: var(--error); }
    .toast-warning .toast-icon { background-color: var(--tertiary-bg); color: var(--warning); }
    .toast-content { flex: 1; }
    .toast-title { font-weight: 600; margin-bottom: 0.25rem; }
    .toast-message { font-size: 0.85rem; color: var(--text-secondary); }
    .toast-close { background: none; border: none; color: var(--text-tertiary); cursor: pointer; font-size: 1rem; }
    .toast-close:hover { color: var(--text-primary); }

    .transcribe-button-container { text-align: center; margin-top: 2rem; padding: 1rem; background-color: var(--primary-bg); border: 1px solid var(--border-color); border-radius: var(--radius); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05); order: 100; }

    /* Media Queries */
    @media (max-width: 1600px) {
      .input-panel-content { flex-direction: column; }
      .settings-column { height: auto; overflow: visible; flex-direction: column; }
      .transcript-controls { flex-direction: column; }
      .transcript-tabs { width: 100%; align-items: center; padding-bottom: 0.5em; }
    }
    @media (max-width: 1920px) {
      .output-panel { flex-direction: column; }
      .preview-panel { flex: none; max-width: none; }
    }

    @media (max-width: 1200px) {
      .app-container { grid-template-columns: 1fr; grid-template-areas: "header" "main"; }
      .header { position: fixed; top: 0; left: 0; right: 0; z-index: 1001; }
      .sidebar { 
        display: none; 
        position: fixed;
        top: var(--header-height);
        left: 0;
        width: 100vw;
        height: calc(100vh - var(--header-height));
        z-index: 1000;
        background-color: var(--primary-bg);
        overflow-y: auto;
      }
      .sidebar.mobile-open {
        display: flex !important;
        animation: slideInFromLeft 0.3s ease-out;
        top: var(--mobile-sidebar-top, var(--header-height)) !important;
        height: var(--mobile-sidebar-height, calc(100vh - var(--header-height))) !important;
      }
      
      @keyframes slideInFromLeft {
        from {
          transform: translateX(-100%);
        }
        to {
          transform: translateX(0);
        }
      }
      .header-buttons { display: flex; }
      .sidebar-toggle { display: block; }
      .input-panel-content { flex-direction: column; }
      .settings-column { height: auto; overflow: visible; flex-direction: column; }
    }
    @media (max-width: 992px) {
      .main-container { flex-direction: column; height: auto; overflow-y: auto; }
      .input-panel { flex: none; max-width: none; height: auto; border-right: none; border-bottom: 1px solid var(--border-color); overflow-y: visible;  }
      .output-panel { height: auto; overflow-y: visible; flex-direction: column; }
      .preview-panel { flex: none; max-width: none; }
      .settings-panel { overflow-y: visible; flex: initial; }
      .transcript-panel { height: 400px; overflow-y: auto; }
    }

    @media (min-width: 993px) { .transcribe-button-container {
            flex-shrink: 0;
            position: sticky;
            bottom: 0;
            padding: 1rem 0;
            margin-top: 0;
            border-top: 1px solid var(--border-color);
            z-index: 5;
        }
    }

    @media (min-width: 1201px) {
      .header-buttons {
        display: flex;
      }
    }

    /* Toggle switch styles */
    .toggle-container { position: relative; display: inline-block; width: 40px; height: 20px; }
    .toggle-container input { opacity: 0; width: 0; height: 0; }
    .toggle-track { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border-color); border-radius: 34px; transition: var(--transition); }
    .toggle-indicator { position: absolute; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; border-radius: 50%; transition: var(--transition); }
    input:checked + .toggle-track { background-color: var(--primary-color); }
    input:checked + .toggle-track .toggle-indicator { transform: translateX(20px); }

    .spacer { flex: 1; }

    .github-section { margin-top: auto !important; border-top: 1px solid var(--border-color); padding-top: 1rem; }

    /* Price Calculator */
    .price-details { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem; }
    .price-row { display: flex; justify-content: space-between; font-size: 0.9rem; }
    .price-label { color: var(--text-secondary); }
    .price-value { font-weight: 500; color: var(--text-primary); }
    .total-cost-row { margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color); font-weight: 600; }

    /* Model Info Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .modal-content {
      background-color: var(--primary-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      width: 90%;
      max-width: 800px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border-color);
    }
    
    .modal-header h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.1rem;
    }
    
    .modal-header i {
      color: var(--primary-color);
    }
    
    .modal-body {
      padding: 1.25rem;
      overflow-y: auto;
      flex: 1;
    }
    
    /* Single column layout for all screen sizes */
    .modal-content {
      max-width: 1600px;
    }
    
    .modal-body {
      display: flex;
      flex-direction: column;
    }
    
    .models-section {
      margin-bottom: 1.5rem;
    }
    
    .models-section:last-child {
      margin-bottom: 0;
    }
    
    /* Model Grid Layouts */
    .models-grid {
      display: grid;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    /* Desktop: 3 columns for both models and API providers */
    @media (min-width: 993px) {
      .models-grid, .api-providers { grid-template-columns: repeat(4, 1fr); }
    }
    
    /* Mobile: 2 columns for both models and API providers */
    @media (max-width: 992px) {
      .models-grid, .api-providers { grid-template-columns: repeat(2, 1fr); }
    }
    
    /* Small mobile: 1 column for everything */
    @media (max-width: 480px) {
      .models-grid {
        grid-template-columns: 1fr;
      }
      .api-providers {
        grid-template-columns: 1fr;
      }
    }
    
    /* Model cards in grid */
    .model-card {
      background-color: var(--secondary-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      padding: 1rem;
    }
    
    .model-card h3 {
      font-size: 0.95rem;
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
      position: relative;
    }
    
    .model-card h3 .model-icon {
      color: inherit;
      font-size: 0.95rem;
    }
    
    .model-card h3 .ri-external-link-line {
      position: absolute;
      right: 0;
      font-size: 0.8rem;
      opacity: 0.7;
      cursor: pointer;
    }
    
    .model-card ul {
      margin: 0;
      padding-left: 1.2rem;
    }
    
    .model-card li {
      color: var(--text-secondary);
      font-size: 0.8rem;
      line-height: 1.3;
      margin-bottom: 0.2rem;
    }
    
    /* Mobile responsive - fill output panel area */
    @media (max-width: 992px) {
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1000;
      }
      
      .modal-content {
        width: 100%;
        height: 100%;
        max-width: none;
        max-height: none;
        border-radius: 0;
        border: none;
        z-index: 1001;
      }
      
      .modal-body {
        padding: 1rem;
        height: calc(100% - 80px); /* Account for header height */
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }
      
      .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        z-index: 1002;
      }
    }

    /* Topics */
    .topic-tag { 
        display: inline-block; 
        background-color: var(--tertiary-bg); 
        color: var(--text-primary); 
        padding: 0.5rem 1rem; 
        border-radius: 1rem; 
        margin: 0 0.5rem 0.5rem; 
        font-size: 1rem; 
        font-weight: 500; 
        border: 1px solid var(--border-color);
        transition: transform 0.2s;
    }
    .topic-tag:hover {
        transform: scale(1.05) rotate(2deg);
        cursor: default;
    }

    .typewriter-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; }
    #headerTypewriterContainer { pointer-events: none; opacity: 0; transition: opacity 0.3s ease-in-out; z-index: 1; }
    #headerTypewriterContainer .typewriter-letter {
      color: var(--primary-color);
      opacity: 0;
      animation: matrixFade 2.5s ease-in-out forwards;
    }
    @keyframes matrixFade {
      0% { opacity: 0; transform: scale(0.8); }
      40% { opacity: 0.7; transform: scale(1); }
      70% {    transform: scale(1.1); }
      100% { opacity: 0; transform: scale(1.2); }
    }

    /* Active model section in Model Info panel */
    .info-section.active-model {
      background-color: var(--tertiary-bg);
      border-radius: var(--radius);
      border-left: 3px solid var(--primary-color);
      padding: 0.5rem 0.75rem;
      margin-bottom: 0.75rem;
    }

    .srt-index, .srt-timing, .vtt-timing { font-size: 0.8em; color: var(--text-tertiary); margin-bottom: 0.25em; }

    /* Edit Mode Styles */
    .transcript-editor {
      width: 100%;
      height: 100%;
      min-height: 300px;
      background-color: var(--primary-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      padding: 1rem;
      font-family: inherit;
      font-size: inherit;
      color: var(--text-primary);
      resize: vertical;
      outline: none;
    }
    .transcript-editor:focus {
      border-color: var(--primary-color);
      background-color: var(--secondary-bg);
    }

    /* Find/Replace Panel */
    .find-replace-panel {
      display: none;
      position: absolute;
      top: 0;
      right: 0;
      background-color: var(--secondary-bg);
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      padding: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 100;
      min-width: 300px;
    }
    .find-replace-panel.active {
      display: block;
    }
    .find-replace-row {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      align-items: center;
    }
    .find-replace-input {
      flex: 1;
      padding: 0.25rem 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: var(--radius);
      background-color: var(--primary-bg);
      color: var(--text-primary);
      font-size: 0.9rem;
    }
    .find-replace-input:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    .find-replace-actions {
      display: flex;
      gap: 0.5rem;
      justify-content: flex-end;
    }

    #cancelEditButton {
      background-color: var(--tertiary-bg) !important;
      border-color: var(--error) !important;
      color: var(--text-primary) !important;
    }
    #cancelEditButton:hover {
      background-color: var(--error) !important;
      border-color: var(--error) !important;
      color: white !important;
    }

    #findReplaceButton.btn-primary {
      background-color: var(--primary-bg) !important;
      border-color: var(--highlight-bg) !important;
      color: var(--text-primary) !important;
    }

    .find-replace-panel.active {
      border-color: var(--highlight-bg) !important;
    }
    .vtt-header { font-weight: bold; margin-bottom: 0.5em; }
    .tsv-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
    .tsv-table th, .tsv-table td { border: 1px solid var(--border-color); padding: 0.4em 0.6em; text-align: left; }
    .tsv-table th { background-color: var(--tertiary-bg); font-weight: 600; }

  </style>
</head>
<body>
  <div class="app-container">
    <header class="header">
      <div class="header-buttons">
        <button id="sidebarToggleBtn" class="btn btn-icon" title="Toggle Sidebar">
          <i class="ri-layout-left-line"></i>
        </button>
      </div>
      <div class="logo">
        <a href="javascript:void(0)" onclick="window.location.reload()">
          <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="var(--primary-color)" d="M4.998 15v4h4v2h-6v-6zm16 0v6h-6v-2h4v-4zm-8-9v12h-2V6zm-4 3v6h-2V9zm8 0v6h-2V9zm-8-6v2h-4v4h-2V3zm12 0v6h-2V5h-4V3z"/></svg>
          <h1><span class="highlight-text">Transcribe</span> Panel</h1>
        </a>
      </div>
    </header>

    <aside class="sidebar">


        <div class="info-section">
          <h2>About</h2>
          <p>Transcribe Panel is an open source interface for local and cloud transcription models. Compare each model's output speed, quality and pricing. Transcripts remain in your browser's cache temporarily and will disappear if you refresh or close the page, so be sure to save your transcript.</p>
        </div>

        <div class="info-section">
          <h2>Settings</h2>
          <div class="options-title">
            <h3 style="color: var(--text-primary);">Notifications</h3>
            <div class="spacer"></div>
            <label class="toggle-container">
              <input type="checkbox" id="notifyToggle">
              <span class="toggle-track"><span class="toggle-indicator"></span></span>
            </label>
          </div>
          <p class="notification-hint">Enable browser notifications when transcription is ready</p>
          <div class="model-options" style="margin-top: 1rem;">
            <div class="options-title"><h3 style="color: var(--text-primary);">Theme</h3></div>
            <div class="theme-model-grid">
              <div class="model-option">
                <input type="radio" name="theme_option" id="themeBtnLight" value="light" checked>
                <label for="themeBtnLight">E Ink</label>
            </div>
              <div class="model-option">
                <input type="radio" name="theme_option" id="themeBtnNova" value="nova">
                <label for="themeBtnNova">Nova</label>
              </div>
              <div class="model-option">
                <input type="radio" name="theme_option" id="themeBtnMinty" value="minty">
                <label for="themeBtnMinty">Minty</label>
              </div>
              <div class="model-option">
                <input type="radio" name="theme_option" id="themeBtnToffee" value="Toffee">
                <label for="themeBtnToffee">Toffee</label>
              </div>
            </div>
          </div>
        </div>

        <div class="info-section">
          <h2>Statistics</h2>
          <div id="transcriptionStats" class="stats">
            <div class="stat-item"><div class="stat-label">Words</div><div class="stat-value">0</div></div>
            <div class="stat-item"><div class="stat-label">Characters</div><div class="stat-value">0</div></div>
            <div class="stat-item"><div class="stat-label">Paragraphs</div><div class="stat-value">0</div></div>
            <div class="stat-item"><div class="stat-label">Elapsed Time</div><div class="stat-value" id="elapsedTimeValue">0s</div></div>
          </div>
          <div id="statsLoading" class="stats-loading" style="display: none;"><span>Calculating</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><defs><filter id="svgSpinnersGooeyBalls20"><feGaussianBlur in="SourceGraphic" result="y" stdDeviation="1"/><feColorMatrix in="y" result="z" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 18 -7"/><feBlend in="SourceGraphic" in2="z"/></filter></defs><g filter="url(#svgSpinnersGooeyBalls20)"><circle cx="5" cy="12" r="4" fill="currentColor"><animate attributeName="cx" calcMode="spline" dur="2s" keySplines=".36,.62,.43,.99;.79,0,.58,.57" repeatCount="indefinite" values="5;8;5"/></circle><circle cx="19" cy="12" r="4" fill="currentColor"><animate attributeName="cx" calcMode="spline" dur="2s" keySplines=".36,.62,.43,.99;.79,0,.58,.57" repeatCount="indefinite" values="19;16;19"/></circle><animateTransform attributeName="transform" dur="0.75s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></g></svg></div>
        </div>

        <div class="info-section github-section">
          <div style="display: flex; justify-content: center;">
            <a href="https://github.com/LandoNikko/Transcribe-Panel" target="_blank" class="btn btn-primary"><i class="ri-github-fill"></i><span>GitHub</span></a>
          </div>
        </div>
    </aside>

    <div class="main-container">
      <div class="input-panel">
          <div class="input-panel-content">
            <div class="files-column">
              <div class="dropzone" id="dropZone">
                <div class="dropzone-left">
                <i class="ri-upload-cloud-2-line"></i>
                <div class="dropzone-title">Upload audio or video file</div>
                </div>
                <div class="dropzone-buttons">
                <button type="button" class="btn btn-secondary" onclick="document.getElementById('local_file').click()">Select Files</button>
                  <span class="button-separator">or</span>
                  <button type="button" class="btn btn-secondary" id="exampleFileBtn" onclick="uploadExampleFile()">Upload Example File</button>
                </div>
                <input type="file" id="local_file" name="file" accept="audio/*,video/*" multiple>
                <input type="file" id="transcript_file" name="transcript_file" accept=".txt,.srt,.vtt,.tsv" style="display: none;">
              </div>
              <div class="file-list">
                <div class="file-list-header">
                  <div class="file-list-title"><i class="ri-file-list-3-line"></i><span>File Queue</span><span class="file-count">0 files</span></div>
                  <div class="file-list-actions">
                    <button type="button" class="btn btn-sm btn-secondary" id="selectAllFiles"><i class="ri-checkbox-multiple-line"></i><span>Select All</span></button>
                    <button type="button" class="btn btn-sm btn-secondary btn-danger-outline" id="clearQueue" disabled><i class="ri-delete-bin-line"></i><span>Clear</span></button>
                  </div>
                </div>
                <div id="fileQueue" class="queue-container">
                </div>
                <div class="progress-container" id="progressContainer">
                    <div class="progress-bar" id="progressBar"></div>
                    <div class="progress-info"><span id="progressMessage">Processing...</span><span id="progressPercent">0%</span></div>
                  </div>
                
              </div>
              
              <div class="settings-content">
                <div class="settings-title"><i class="ri-settings-3-line"></i><h2>Model Settings</h2><button class="btn btn-icon" style="margin-left: auto;" title="Help"><i class="ri-question-line"></i></button></div>
                <div class="model-options">
                  <div class="model-tabs-header">
                    <button type="button" class="model-tab-button" id="localTabButton" data-tab="local">
                      <i class="ri-computer-line"></i>
                      Local Models
                    </button>
                    <button type="button" class="model-tab-button active" id="cloudTabButton" data-tab="cloud">
                      <i class="ri-cloud-line"></i>
                      Cloud Models
                    </button>
                  </div>
                  
                  <div class="model-tab-content" id="localTabContent">
                    <div class="local-model-grid">
                      <div class="model-option"><input type="radio" name="model_option" id="tiny" value="tiny"><label for="tiny"><div class="model-left"><span class="model-icon" data-model="tiny"></span><div class="model-name">Tiny</div></div></label></div>
                      <div class="model-option"><input type="radio" name="model_option" id="base" value="base"><label for="base"><div class="model-left"><span class="model-icon" data-model="base"></span><div class="model-name">Base</div></div></label></div>
                      <div class="model-option"><input type="radio" name="model_option" id="small" value="small"><label for="small"><div class="model-left"><span class="model-icon" data-model="small"></span><div class="model-name">Small</div></div></label></div>
                      <div class="model-option"><input type="radio" name="model_option" id="medium" value="medium"><label for="medium"><div class="model-left"><span class="model-icon" data-model="medium"></span><div class="model-name">Medium</div></div></label></div>
                      <div class="model-option"><input type="radio" name="model_option" id="turbo" value="turbo"><label for="turbo"><div class="model-left"><span class="model-icon" data-model="turbo"></span><div class="model-name">Turbo</div></div></label></div>
                      <div class="model-option"><input type="radio" name="model_option" id="large" value="large"><label for="large"><div class="model-left"><span class="model-icon" data-model="large"></span><div class="model-name">Large</div></div></label></div>
                    </div>
                    <div id="localModelsNotice" style="display: none; margin-top: 1rem; padding: 0.75rem 1rem; border: 1px solid var(--warning); border-radius: var(--radius); color: var(--text-secondary); font-size: 0.9rem;">
                      <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <i class="ri-alert-line" style="color: var(--warning);"></i>
                        <span style="font-weight: 500; color: var(--text-primary);">Python Setup Required</span>
                      </div>
                      <p style="margin: 0; line-height: 1.4;">
                        Local models require Python backend server to be running. See the <a href="https://github.com/LandoNikko/Transcribe-Panel" target="_blank" style="color: var(--primary-color); text-decoration: none;">GitHub repository</a> for setup instructions.
                      </p>
                      </div>
                  </div>
                  
                  <div class="model-tab-content active" id="cloudTabContent">
                    <div class="cloud-model-grid">
                    <div class="model-option">
                      <input type="radio" name="model_option" id="whisper-1" value="whisper-1" checked>
                      <label for="whisper-1"><div class="model-left"><span class="model-icon" data-model="whisper-1"></span><div class="model-name">Whisper-1</div></div><div class="model-desc">OpenAI</div></label>
                    </div>
                    <div class="model-option">
                      <input type="radio" name="model_option" id="gpt-4o-mini-transcribe" value="gpt-4o-mini-transcribe">
                      <label for="gpt-4o-mini-transcribe"><div class="model-left"><span class="model-icon" data-model="gpt-4o-mini-transcribe"></span><div class="model-name">4o Mini</div></div><div class="model-desc">OpenAI</div></label>
                   </div>
                    <div class="model-option">
                      <input type="radio" name="model_option" id="gpt-4o-transcribe" value="gpt-4o-transcribe">
                      <label for="gpt-4o-transcribe"><div class="model-left"><span class="model-icon" data-model="gpt-4o-transcribe"></span><div class="model-name">4o</div></div><div class="model-desc">OpenAI</div></label>
                   </div>
                    <div class="model-option">
                      <input type="radio" name="model_option" id="nova-3" value="nova-3">
                      <label for="nova-3"><div class="model-left"><span class="model-icon" data-model="nova-3"></span><div class="model-name">Nova-3</div></div><div class="model-desc">Deepgram</div></label>
                    </div>
                    <div class="model-option">
                      <input type="radio" name="model_option" id="gladia" value="gladia">
                      <label for="gladia"><div class="model-left"><span class="model-icon" data-model="gladia"></span><div class="model-name">Gladia v2</div></div><div class="model-desc">Gladia</div></label>
                    </div>
                    <div class="model-option">
                      <input type="radio" name="model_option" id="scribe-v1" value="scribe-v1">
                      <label for="scribe-v1">
                        <div class="model-left">
                        <span class="model-icon" data-model="scribe-v1"></span>
                        <div class="model-name">Scribe v1</div>
                        </div>
                        <div class="model-desc">ElevenLabs</div>
                      </label>
                    </div>
                    </div>
                  </div>
                </div>
                <!-- API Key Sections -->
                <div class="api-key-section" id="openaiApiKeySection" style="display: none;">
                  <div class="options-title"><i class="ri-key-2-line"></i><h3>OpenAI API Key</h3></div>
                  <div class="api-key-input"><input type="password" id="api_key_cloud" name="api_key_cloud" placeholder="Enter your OpenAI API key" class="input"><button type="button" class="btn btn-secondary" id="showOpenApiKey"><i class="ri-eye-line"></i></button></div>
                  <p class="api-help-text">Need help getting an API key? Check the <strong>Model Information</strong> modal (? button above) for setup instructions.</p>
                </div>
                <div class="api-key-section" id="deepgramApiKeySection" style="display: none;">
                  <div class="options-title"><i class="ri-key-2-line"></i><h3>Deepgram API Key</h3></div>
                  <div class="api-key-input"><input type="password" id="deepgram_api_key" name="deepgram_api_key" placeholder="Enter your Deepgram API key" class="input"><button type="button" class="btn btn-secondary" id="showDeepgramApiKey"><i class="ri-eye-line"></i></button></div>
                  <p class="api-help-text">Need help getting an API key? Check the <strong>Model Information</strong> modal (? button above) for setup instructions.</p>
                </div>
                <div class="api-key-section" id="gladiaApiKeySection" >
                  <div class="options-title"><i class="ri-key-2-line"></i><h3>Gladia API Key</h3></div>
                  <div class="api-key-input"><input type="password" id="gladia_api_key" name="gladia_api_key" placeholder="Enter your Gladia API key" class="input"><button type="button" class="btn btn-secondary" id="showGladiaApiKey"><i class="ri-eye-line"></i></button></div>
                  <p class="api-help-text">Need help getting an API key? Check the <strong>Model Information</strong> modal (? button above) for setup instructions.</p>
                </div>
                <div class="api-key-section" id="elevenlabsApiKeySection" style="display: none;">
                    <div class="options-title"><i class="ri-key-2-line"></i><h3>ElevenLabs API Key</h3></div>
                    <div class="api-key-input">
                        <input type="password" id="elevenlabs_api_key" name="elevenlabs_api_key" placeholder="Enter your ElevenLabs API key" class="input">
                        <button type="button" class="btn btn-secondary" id="showElevenLabsApiKey"><i class="ri-eye-line"></i></button>
                    </div>
                    <p class="api-help-text">Need help getting an API key? Check the <strong>Model Information</strong> modal (? button above) for setup instructions.</p>
                </div>
                <div id="deepgramOptions" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                  <div class="options-title"><i class="ri-robot-line"></i><h3>Deepgram AI Features (English Only)</h3></div>
                  <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-top: 0.5rem;">
                    <label class="checkbox-container" style="font-size: 0.9rem;"><input type="checkbox" id="deepgram_summarize"><span class="checkbox-custom"><i class="ri-check-line"></i></span><h4>Summarization</h4></label>
                    <p class="api-key-hint" id="summarizeHint" style="margin-top: -0.5rem; margin-left: 2rem; display: none; color: var(--text-secondary); font-size: 0.9rem;">Short summary for fast insight.</p>
                    <label class="checkbox-container" style="margin-top: 0.5rem; font-size: 0.9rem;"><input type="checkbox" id="deepgram_topics"><span class="checkbox-custom"><i class="ri-check-line"></i></span><h4>Topic Detection</h4></label>
                    <p class="api-key-hint" id="topicsHint" style="margin-top: -0.5rem; margin-left: 2rem; display: none; color: var(--text-secondary); font-size: 0.9rem;">Labels main topics for quick understanding.</p>
                    </div>
                </div>
                                  <div id="gpt4o-prompt-section" style="display: none; margin-top: 15px;">
                                    <div class="options-title"><i class="ri-chat-1-line"></i><h3>Transcription Prompt</h3></div>
                                    <div>
                                      <textarea id="gpt4o_prompt" name="gpt4o_prompt" 
                                                placeholder="Enter optional prompt. Output can be improved by adding specific details about the content or translate to a different language."
                                                class="input" style="min-height: 90px; width: 100%;"></textarea>
                                    </div>
                                  </div>
                 <div id="priceCalculator" style="display: none; margin-top: 1.5rem; padding: 1rem; background-color: var(--secondary-bg); border-radius: var(--radius); border: 1px solid var(--border-color);">
                    <div class="options-title"><h4>Price Calculator</h4><a id="pricingDocLink" href="#" target="_blank" style="margin-left: auto; color: var(--text-tertiary); cursor: pointer;" title="Pricing model"><i class="ri-question-line" style="opacity: 0.7;"></i></a></div>
                    <div class="price-details">
                        <div class="price-row" id="fileDurationRow"><span class="price-label">File Duration:</span><span class="price-value" id="fileDuration">N/A</span></div>
                        <div class="price-row" id="apiPricingRow"><span class="price-label" id="apiPricingLabel">API Base Cost:</span><span class="price-value" id="apiPricingValue">N/A</span></div>
                        <div class="price-row" id="summarizationCostRow" style="display: none;"><span class="price-label">Summarization:</span><span class="price-value" id="summarizationCostValue">$0.00</span></div>
                        <div class="price-row" id="topicDetectionCostRow" style="display: none;"><span class="price-label">Topic Detection:</span><span class="price-value" id="topicDetectionCostValue">$0.00</span></div>
                        <div class="price-row total-cost-row"><span class="price-label">Total Estimated:</span><span class="price-value" id="estimatedCost">$0.00</span></div>
                    </div>
                </div>
              </div>

              <div class="transcribe-button-container">
                <button type="submit" class="btn btn-primary btn-large" id="transcribeButton"><i class="ri-draft-line"></i><span>Transcribe</span></button>
              </div>
            </div>
              </div>

          <input type="hidden" id="job_id" name="job_id" value="">
      </div>

      <div class="output-panel">
        <div class="preview-panel">
          <div class="preview-title">
            <div class="preview-title-text"><i class="ri-play-circle-line"></i><h2>Media Preview</h2></div>
            <div class="preview-options">
              <button type="button" class="btn btn-sm btn-secondary" id="showVideo" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><rect width="20" height="16" x="2" y="4" rx="4"/><path d="m15 12l-5-3v6z"/></g></svg><span>Video</span></button>
              <button type="button" class="btn btn-sm btn-secondary" id="showWaveform" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="m22 12l-2 1l-1 1l-1-1l-1 3l-1-3l-1 8l-1-8l-1 2l-1-2l-1 4l-1-4l-1 9l-1-9l-1 6l-1-6l-1 1l-1-1l-2-1l2-1l1-1l1 1l1-6l1 6l1-9l1 9l1-4l1 4l1-2l1 2l1-8l1 8l1-3l1 3l1-1l1 1z"/></svg><span>Waveform</span></button>
            </div>
          </div>
          <video id="previewPlayer" class="preview-player" controls></video>
          <div id="audioPlayer" class="waveform-container">
            <div class="controls"><button id="playPauseButton" class="play-btn"><i class="ri-play-fill"></i></button></div>
            <div id="waveform" class="wave-wrapper"><div class="time-display"><span class="time-left">0:00</span><span class="time-center"></span><span class="time-right">0:00</span></div></div>
          </div>
        </div>
        <div class="transcript-panel">
          <div class="transcript-header">
            <div class="transcript-title">
              <div class="transcript-title-content"><i class="ri-file-text-line"></i><h2>Transcript</h2></div>
            </div>
            <div class="transcript-controls">
              <div class="transcript-tabs">
                <select class="transcript-dropdown" id="transcriptFormatSelect">
                  <option value="default">Default</option>
                  <option value="numbered">#</option>
                  <option value="srt">SRT</option>
                  <option value="vtt">VTT</option>
                  <option value="tsv">TSV</option>
                  <option value="summary" style="display: none;">Summary</option>
                  <option value="topics" style="display: none;">Topics</option>
                </select>
                <div class="zoom-group">
                <button type="button" class="btn btn-sm btn-secondary" id="fontDecreaseBtn" title="Decrease font size"><i class="ri-subtract-line"></i></button>
                <button type="button" class="btn btn-sm btn-secondary" id="fontIncreaseBtn" title="Increase font size"><i class="ri-add-line"></i></button>
                </div>
              </div>
              <div class="transcript-actions">
                <button type="button" class="btn btn-sm btn-secondary" id="findReplaceButton" style="display: none;"><i class="ri-search-2-line"></i><span>Find & Replace</span><i class="ri-arrow-down-s-line"></i></button>
                <button type="button" class="btn btn-sm btn-secondary" id="cancelEditButton" style="display: none;"><i class="ri-close-line"></i><span>Cancel</span></button>
                <button type="button" class="btn btn-sm btn-secondary" id="editButton" disabled><i class="ri-edit-line"></i><span>Edit</span></button>
                <button type="button" class="btn btn-sm btn-secondary" id="copyButton" disabled><i class="ri-clipboard-line"></i><span>Copy</span></button>
                <div class="upload-download-group">
                  <button type="button" class="btn btn-sm btn-secondary" id="uploadButton"><i class="ri-upload-line"></i><span>Upload</span></button>
                  <div class="download-dropdown disabled" id="downloadDropdown">
                    <button type="button" class="btn btn-sm btn-secondary" id="downloadButton" disabled><i class="ri-download-line"></i><span>Download</span><i class="ri-arrow-down-s-line"></i></button>
                    <div class="download-options">
                      <div class="download-option" data-format="default">Default (.txt)</div>
                      <div class="download-option" data-format="numbered">Numbered (.txt)</div>
                      <div class="download-option" data-format="srt">SRT (.srt)</div>
                      <div class="download-option" data-format="vtt">VTT (.vtt)</div>
                      <div class="download-option" data-format="tsv">TSV (.tsv)</div>
              </div>
            </div>
          </div>
              </div>
            </div>
          </div>
          <div class="loading-overlay" id="loadingOverlay" style="display: none;"><div class="typewriter-container" id="typewriterContainer"></div><div class="loading-message"><div class="loading-text">Processing Transcript</div><div class="loading-bars"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect width="2.8" height="12" x="1" y="6" fill="currentColor"><animate id="svgSpinnersBarsScale0" attributeName="y" begin="0;svgSpinnersBarsScale1.end-0.1s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="6;1;6"/><animate attributeName="height" begin="0;svgSpinnersBarsScale1.end-0.1s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="12;22;12"/></rect><rect width="2.8" height="12" x="5.8" y="6" fill="currentColor"><animate attributeName="y" begin="svgSpinnersBarsScale0.begin+0.1s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="6;1;6"/><animate attributeName="height" begin="svgSpinnersBarsScale0.begin+0.1s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="12;22;12"/></rect><rect width="2.8" height="12" x="10.6" y="6" fill="currentColor"><animate attributeName="y" begin="svgSpinnersBarsScale0.begin+0.2s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="6;1;6"/><animate attributeName="height" begin="svgSpinnersBarsScale0.begin+0.2s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="12;22;12"/></rect><rect width="2.8" height="12" x="15.4" y="6" fill="currentColor"><animate attributeName="y" begin="svgSpinnersBarsScale0.begin+0.3s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="6;1;6"/><animate attributeName="height" begin="svgSpinnersBarsScale0.begin+0.3s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="12;22;12"/></rect><rect width="2.8" height="12" x="20.2" y="6" fill="currentColor"><animate id="svgSpinnersBarsScale1" attributeName="y" begin="svgSpinnersBarsScale0.begin+0.4s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="6;1;6"/><animate attributeName="height" begin="svgSpinnersBarsScale0.begin+0.4s" calcMode="spline" dur="0.6s" keySplines=".36,.61,.3,.98;.36,.61,.3,.98" values="12;22;12"/></rect></svg></div></div></div>
          
          <div class="transcript-content" id="defaultTranscript">
            <div class="transcript-body"></div>
            <div class="find-replace-panel">
              <div class="find-replace-row">
                <label>Find:</label>
                <input type="text" class="find-replace-input" id="findInput" placeholder="Search text...">
                <button type="button" class="btn btn-sm btn-secondary" id="findNextBtn">Next</button>
                <button type="button" class="btn btn-sm btn-secondary" id="findPrevBtn">Prev</button>
              </div>
              <div class="find-replace-row">
                <label>Replace:</label>
                <input type="text" class="find-replace-input" id="replaceInput" placeholder="Replace with...">
                <button type="button" class="btn btn-sm btn-secondary" id="replaceBtn">Replace</button>
                <button type="button" class="btn btn-sm btn-secondary" id="replaceAllBtn">All</button>
              </div>
            </div>
          </div>
          <div class="transcript-content" id="numberedTranscript" style="display: none;"><div class="transcript-body"></div></div>
          <div class="transcript-content" id="srtTranscript" style="display: none;"><div class="transcript-body"></div></div>
          <div class="transcript-content" id="vttTranscript" style="display: none;"><div class="transcript-body"></div></div>
          <div class="transcript-content" id="tsvTranscript" style="display: none;"><div class="transcript-body"></div></div>
          <div class="transcript-content" id="summaryTranscript" style="display: none;"><h2>Summary</h2><div class="transcript-body" style="white-space: pre-wrap; margin-top: 1rem;"></div></div>
          <div class="transcript-content" id="topicsTranscript" style="display: none;"><h2>Detected Topics</h2><div class="transcript-body" style="margin-top: 1rem;"></div></div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast-container">
      <!-- Toasts  -->
  </div>

  <script src="https://unpkg.com/wavesurfer.js"></script>
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    let fileQueue = [];
    let currentProcessingIndex = -1;
    
    // Unified cache system - replaces fileResults, savedTranscriptionsByFile, completedModelsByFile
    let fileCache = new Map();
    
    let currentActiveFile = null;
    let activeProcessingQueue = [];
    let currentUploadedFile = null;
    let generationInProgress = false;
    let wavesurfer;
    let videoWavesurfer;
    let currentPreviewedFile = null;
    let progressInterval;
    let socket = null;
    let isCancelled = false;
    let currentFontSize = 16;
    let typewriterInterval = null;
    let currentFileDuration = 0;
    let highlightScheduled = false;
    let queuedHighlightTime = null;
    let isEditMode = false;
    let currentEditor = null;
    let originalEditContent = null;
    let priceCalcDebounceId = null;
    let serverAvailable = false;
    let serverCheckComplete = false;

    // Pricing constants
    const DEEPGRAM_INPUT_TOKEN_COST = 0.0003 / 1000;
    const DEEPGRAM_OUTPUT_TOKEN_COST = 0.0006 / 1000;
    const AVG_WORDS_PER_MINUTE = 150;
    const AVG_TOKENS_PER_WORD = 1.3;
    const SUMMARY_OUTPUT_PERCENTAGE = 0.2;
    const ELEVENLABS_SCRIBE_COST_PER_MINUTE = 0.35 / 60;

    // Cache helper functions
    function getFileTranscription(fileId, model) {
      if (!fileId || !model) return null;
      const fileData = fileCache.get(fileId);
      return fileData?.transcriptions?.[model];
    }

    function setFileTranscription(fileId, model, data) {
      if (!fileId || !model || !data) return;
      
      if (!fileCache.has(fileId)) {
        fileCache.set(fileId, { 
          metadata: { name: '', size: 0, duration: 0 },
          transcriptions: {} 
        });
      }
      fileCache.get(fileId).transcriptions[model] = data;
    }

    function getCompletedModels(fileId) {
      if (!fileId) return [];
      const fileData = fileCache.get(fileId);
      return fileData ? Object.keys(fileData.transcriptions) : [];
    }

    function getCurrentFileResult(fileId) {
      if (!fileId) return null;
      const fileData = fileCache.get(fileId);
      if (!fileData) return null;
      
      const selectedModel = getSelectedModel();
      if (!selectedModel) return null;
      return fileData.transcriptions[selectedModel] || null;
    }

    function clearFileCache(fileId) {
      if (!fileId) return;
      fileCache.delete(fileId);
    }

    function clearAllFileCache() {
      fileCache.clear();
    }

    // API Key Cache
    const apiKeyCache = new Map();
    
    function saveApiKeyIfChanged(keyType, newValue) {
      const currentValue = apiKeyCache.get(keyType);
      if (currentValue !== newValue) {
        localStorage.setItem(keyType, newValue);
        apiKeyCache.set(keyType, newValue);
      }
    }

    function loadApiKeysToCache() {
      apiKeyCache.set('openaiApiKey', localStorage.getItem('openaiApiKey') || '');
      apiKeyCache.set('deepgramApiKey', localStorage.getItem('deepgramApiKey') || '');
      apiKeyCache.set('gladiaApiKey', localStorage.getItem('gladiaApiKey') || '');
      apiKeyCache.set('elevenlabsApiKey', localStorage.getItem('elevenlabsApiKey') || '');
    }

    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('local_file');
    const fileQueueEl = document.getElementById('fileQueue');
    const transcribeButton = document.getElementById('transcribeButton');
    const copyButton = document.getElementById('copyButton');
    const downloadButton = document.getElementById('downloadButton');
    const uploadButton = document.getElementById('uploadButton');
    const transcriptFileInput = document.getElementById('transcript_file');
    const editButton = document.getElementById('editButton');
    const cancelEditButton = document.getElementById('cancelEditButton');
    const findReplaceButton = document.getElementById('findReplaceButton');
    const findReplacePanel = document.querySelector('.find-replace-panel');
    const findInput = document.getElementById('findInput');
    const replaceInput = document.getElementById('replaceInput');
    const progressBar = document.getElementById('progressBar');
    const progressMessage = document.getElementById('progressMessage');
    const progressPercent = document.getElementById('progressPercent');
    const apiKeySection = document.getElementById('apiKeySection');
    const previewPlayer = document.getElementById('previewPlayer');
    const audioPlayerContainer = document.getElementById('audioPlayer');
    const waveformEl = document.getElementById('waveform');
    const playPauseButton = document.getElementById('playPauseButton');
    const showVideoBtn = document.getElementById('showVideo');
    const showWaveformBtn = document.getElementById('showWaveform');
    const clearQueueBtn = document.getElementById('clearQueue');
    const selectAllFilesBtn = document.getElementById('selectAllFiles');
    const fileCountEl = document.querySelector('.file-count');
    const statsContainer = document.getElementById('transcriptionStats');
    const statsLoading = document.getElementById('statsLoading');
    const elapsedTimeValueEl = document.getElementById('elapsedTimeValue');
    const deepgramOptionsDiv = document.getElementById('deepgramOptions');
    const summarizeCheckbox = document.getElementById('deepgram_summarize');
    const topicsCheckbox = document.getElementById('deepgram_topics');
    const transcriptFormatSelect = document.getElementById('transcriptFormatSelect');
    const summaryOption = transcriptFormatSelect.querySelector('option[value="summary"]');
    const topicsOption = transcriptFormatSelect.querySelector('option[value="topics"]');
    const summaryTranscriptDiv = document.getElementById('summaryTranscript');
    const topicsTranscriptDiv = document.getElementById('topicsTranscript');
    const priceCalculatorDiv = document.getElementById('priceCalculator');
    const fileDurationValue = document.getElementById('fileDuration');
    const apiPricingLabel = document.getElementById('apiPricingLabel');
    const apiPricingValue = document.getElementById('apiPricingValue');
    const summarizationCostRow = document.getElementById('summarizationCostRow');
    const summarizationCostValue = document.getElementById('summarizationCostValue');
    const topicDetectionCostRow = document.getElementById('topicDetectionCostRow');
    const topicDetectionCostValue = document.getElementById('topicDetectionCostValue');
    const estimatedCostValue = document.getElementById('estimatedCost');
    const deepgramApiKeySection = document.getElementById('deepgramApiKeySection');
    const gladiaApiKeySection = document.getElementById('gladiaApiKeySection');
    const elevenlabsApiKeySection = document.getElementById('elevenlabsApiKeySection');

    // DOM cache for frequently accessed elements
    const domCache = {
      sidebarButton: null, sidebar: null, appContainer: null, mainContainer: null,
      sidebarIcon: null, header: null, tabButtons: null, tabContents: null,
      localTabButton: null, cloudTabButton: null, localTabContent: null, cloudTabContent: null,
      modelRadios: null, modelInfoSections: null, priceCalculator: null, progressBar: null,
      progressPercent: null, loadingOverlay: null, progressContainer: null, typewriterContainer: null,
      
      init() {
        // Sidebar elements
        this.sidebarButton = document.getElementById('sidebarToggleBtn');
        this.sidebar = document.querySelector('.sidebar');
        this.appContainer = document.querySelector('.app-container');
        this.mainContainer = document.querySelector('.main-container');
        this.header = document.querySelector('.header');
        this.sidebarIcon = this.sidebarButton?.querySelector('i');
        
        // Model elements
        this.tabButtons = document.querySelectorAll('.model-tab-button');
        this.tabContents = document.querySelectorAll('.model-tab-content');
        this.localTabButton = document.getElementById('localTabButton');
        this.cloudTabButton = document.getElementById('cloudTabButton');
        this.localTabContent = document.getElementById('localTabContent');
        this.cloudTabContent = document.getElementById('cloudTabContent');
        this.modelRadios = document.querySelectorAll('input[name="model_option"]');
        this.modelInfoSections = document.querySelectorAll('#modelInfoModal .info-section');
        
        // Frequently queried elements
        this.priceCalculator = document.getElementById('priceCalculator');
        this.progressBar = document.querySelector('.progress-bar');
        this.progressPercent = document.querySelector('.progress-percent');
        this.loadingOverlay = document.getElementById('loadingOverlay');
        this.progressContainer = document.querySelector('.progress-container');
        this.typewriterContainer = document.getElementById('typewriterContainer');
      }
    };

    // Legacy compatibility objects
    const sidebarElements = {
      get button() { return domCache.sidebarButton; },
      get sidebar() { return domCache.sidebar; },
      get appContainer() { return domCache.appContainer; },
      get mainContainer() { return domCache.mainContainer; },
      get icon() { return domCache.sidebarIcon; },
      get header() { return domCache.header; }
    };

    const modelElements = {
      get tabButtons() { return domCache.tabButtons; },
      get tabContents() { return domCache.tabContents; },
      get localTabButton() { return domCache.localTabButton; },
      get cloudTabButton() { return domCache.cloudTabButton; },
      get localTabContent() { return domCache.localTabContent; },
      get cloudTabContent() { return domCache.cloudTabContent; },
      get modelRadios() { return domCache.modelRadios; },
      get modelInfoSections() { return domCache.modelInfoSections; }
    };

    function updateSidebarIcon(state) {
      const iconMap = {
        'desktop-open': 'ri-layout-left-line',
        'closed': 'ri-layout-left-2-line', 
        'mobile-open': 'ri-close-line'
      };
      if (sidebarElements.icon && iconMap[state]) {
        sidebarElements.icon.className = iconMap[state];
      }
    }

    function getSelectedModel() {
      const checkedRadio = Array.from(modelElements.modelRadios || []).find(radio => radio.checked);
      return checkedRadio ? checkedRadio.value : null;
    }

    document.addEventListener('DOMContentLoaded', function() {
      domCache.init();
      loadApiKeysToCache();
      initializeModelIcons();
      handleScreenSize();
      
      fileInput.addEventListener('change', handleFileSelection);
      dropZone.addEventListener('dragover', handleDragOver);
      dropZone.addEventListener('dragleave', handleDragLeave);
      dropZone.addEventListener('drop', handleFileDrop);
      copyButton.addEventListener('click', copyTranscript);
      
      const downloadOptions = document.querySelectorAll('.download-option');
      downloadOptions.forEach(option => {
        option.addEventListener('click', (e) => {
          const format = e.currentTarget.getAttribute('data-format');
          downloadTranscriptFormat(format);
        });
      });
      uploadButton.addEventListener('click', () => transcriptFileInput.click());
      transcriptFileInput.addEventListener('change', handleTranscriptUpload);
      editButton.addEventListener('click', toggleEditMode);
      cancelEditButton.addEventListener('click', cancelEditMode);
      findReplaceButton.addEventListener('click', toggleFindReplace);
      clearQueueBtn.addEventListener('click', clearQueue);
      selectAllFilesBtn.addEventListener('click', selectAllFiles);
      transcribeButton.addEventListener('click', handleFormSubmit);
      playPauseButton.addEventListener('click', togglePlayPause);
      document.getElementById('fontDecreaseBtn').addEventListener('click', decreaseFontSize);
      document.getElementById('fontIncreaseBtn').addEventListener('click', increaseFontSize);
      document.getElementById('findNextBtn').addEventListener('click', findNext);
      document.getElementById('findPrevBtn').addEventListener('click', findPrevious);
      document.getElementById('replaceBtn').addEventListener('click', replaceOne);
      document.getElementById('replaceAllBtn').addEventListener('click', replaceAll);
      
      // Ctrl+F support for find/replace in edit mode
      document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'f' && isEditMode) {
          e.preventDefault();
          if (!findReplacePanel.classList.contains('active')) {
            toggleFindReplace();
          }
        } else if (e.key === 'Escape' && findReplacePanel.classList.contains('active')) {
          toggleFindReplace();
        }
      });

      // API key visibility toggles
      document.getElementById('showOpenApiKey').addEventListener('click', function() { togglePasswordVisibility('api_key_cloud', this); });
      document.getElementById('showDeepgramApiKey').addEventListener('click', function() { togglePasswordVisibility('deepgram_api_key', this); });
      document.getElementById('showGladiaApiKey').addEventListener('click', function() { togglePasswordVisibility('gladia_api_key', this); });
      document.getElementById('showElevenLabsApiKey').addEventListener('click', function() { togglePasswordVisibility('elevenlabs_api_key', this); });

      document.querySelectorAll('input[name="theme_option"]').forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            switchTheme(this.value);
          }
        });
      });


      transcriptFormatSelect.addEventListener('change', function() { switchTab(this.value); });

      modelElements.tabButtons.forEach(button => {
        button.addEventListener('click', function() {
          switchModelTab(this.dataset.tab);
        });
      });

      modelElements.modelRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          handleModelSelection();
        });
      });
      
      document.getElementById('notifyToggle').addEventListener('change', requestNotificationPermission);
      summarizeCheckbox.addEventListener('change', handleDeepgramFeatureChange);
      topicsCheckbox.addEventListener('change', handleDeepgramFeatureChange);
      
      showVideoBtn.addEventListener('click', showVideoPreview);
      showWaveformBtn.addEventListener('click', showWaveformPreview);

      handleModelSelection();
      checkServerAvailability();
      loadSavedApiKeys();
      initializeTheme();
      setupApiKeyHeadersToggles();
      audioPlayerContainer.style.display = 'none';
      updateTranscribeButtonText();
      document.getElementById('job_id').value = 'job_' + Math.random().toString(36).substr(2, 9);
      
      if (domCache.priceCalculator) {
        requestPriceCalculatorUpdate();
      } else {
        console.error('Price calculator element not found!');
      }
      
      clearQueueBtn.disabled = true;
      selectAllFilesBtn.disabled = true;
      downloadButton.disabled = true;
      copyButton.disabled = true;
      
      function handleScreenSize() {
        if (!sidebarElements.sidebar || !sidebarElements.appContainer || !sidebarElements.button) return;
        
        if (window.innerWidth <= 1200) {
          // Small screens - hide sidebar initially but keep toggle button visible
          sidebarElements.sidebar.classList.remove('mobile-open');
          sidebarElements.sidebar.style.display = 'none';
          sidebarElements.appContainer.style.gridTemplateColumns = '1fr';
          sidebarElements.appContainer.style.gridTemplateAreas = '"header" "main"';
          sidebarElements.button.style.display = 'flex'; // Keep toggle button visible
          updateSidebarIcon('closed'); // Show closed state
        } else {
          // Large screens - show sidebar and info button
          sidebarElements.sidebar.classList.remove('mobile-open');
          sidebarElements.sidebar.style.display = 'flex';
          sidebarElements.appContainer.style.gridTemplateColumns = 'var(--sidebar-width) 1fr';
          sidebarElements.appContainer.style.gridTemplateAreas = '"header header" "sidebar main"';
          sidebarElements.button.style.display = 'flex';
          updateSidebarIcon('desktop-open');
        }
      }
      
      // Note: handleScreenSize() will be called after DOM elements are cached in DOMContentLoaded
      setTimeout(() => {
        updateHeaderVisibility();
        const header = domCache.header;
        const isMobile = window.innerWidth <= 1200;
        if (isMobile) {
          header.classList.add('header-visible');
          header.classList.remove('header-hidden');
        }
      }, 100);
      window.addEventListener('resize', function() {
        if (window.innerWidth > 1200 && sidebarElements.sidebar?.classList.contains('mobile-open')) {
          sidebarElements.sidebar.classList.remove('mobile-open');
          updateSidebarIcon('desktop-open');
        }
        
        handleScreenSize();
        updateHeaderVisibility();
      });
      
      document.addEventListener('click', function(event) {
        const isMobile = window.innerWidth <= 1200;
        
        if (isMobile && sidebarElements.sidebar?.classList.contains('mobile-open')) {
          if (!sidebarElements.sidebar.contains(event.target) && !sidebarElements.button?.contains(event.target)) {
            sidebarElements.sidebar.classList.remove('mobile-open');
            sidebarElements.sidebar.style.display = 'none';
            
            // Restore background scrolling when mobile sidebar is closed
            document.body.style.overflow = '';
            
            updateSidebarIcon('closed');
          }
        }
      });
      
      let lastScrollY = window.scrollY;
      let ticking = false;
      
      function updateHeaderVisibility() {
        const header = domCache.header;
        const sidebar = domCache.sidebar;
        const isMobile = window.innerWidth <= 1200;
        
        if (!isMobile) {
          header.classList.remove('header-hidden', 'header-visible');
          return;
        }
        
        if (sidebar && sidebar.classList.contains('mobile-open')) {
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
          document.documentElement.style.setProperty('--mobile-sidebar-top', 'var(--header-height)');
          document.documentElement.style.setProperty('--mobile-sidebar-height', 'calc(100vh - var(--header-height))');
          lastScrollY = window.scrollY;
          ticking = false;
          return;
        }
        
        const currentScrollY = window.scrollY;
        const scrollDifference = currentScrollY - lastScrollY;
        
        if (scrollDifference < -2 || currentScrollY < 50) {
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
        }
        else if (scrollDifference > 3 && currentScrollY > 80) {
          header.classList.remove('header-visible');
          header.classList.add('header-hidden');
        }
        
        lastScrollY = currentScrollY;
        ticking = false;
      }
      
      function requestHeaderUpdate() {
        if (!ticking) {
          requestAnimationFrame(updateHeaderVisibility);
          ticking = true;
        }
      }
      
      window.addEventListener('scroll', requestHeaderUpdate);
      
      sidebarElements.button?.addEventListener('click', function() {
        const isMobile = window.innerWidth <= 1200;
        
        // Null safety check before using getComputedStyle
        if (!sidebarElements.sidebar) return;
        
        const sidebarHidden = getComputedStyle(sidebarElements.sidebar).display === 'none';
        const isMobileSidebarOpen = isMobile && sidebarElements.sidebar.classList.contains('mobile-open');
        
        if (sidebarHidden || (isMobile && !isMobileSidebarOpen)) {
          if (isMobile) {
            sidebarElements.sidebar.classList.add('mobile-open');
            sidebarElements.sidebar.style.display = 'flex';
            
            document.body.style.overflow = 'hidden';
            
            if (sidebarElements.header.classList.contains('header-hidden')) {
              document.documentElement.style.setProperty('--mobile-sidebar-top', '0');
              document.documentElement.style.setProperty('--mobile-sidebar-height', '100vh');
            } else {
              document.documentElement.style.setProperty('--mobile-sidebar-top', 'var(--header-height)');
              document.documentElement.style.setProperty('--mobile-sidebar-height', 'calc(100vh - var(--header-height))');
            }
            
            updateSidebarIcon('mobile-open');
          } else {
            sidebarElements.sidebar.style.display = 'flex';
            sidebarElements.appContainer.style.gridTemplateColumns = 'var(--sidebar-width) 1fr';
            sidebarElements.appContainer.style.gridTemplateAreas = '"header header" "sidebar main"';
            updateSidebarIcon('desktop-open');
          }
        } else {
          if (isMobile) {
            sidebarElements.sidebar.classList.remove('mobile-open');
            sidebarElements.sidebar.style.display = 'none';
            
            // Restore background scrolling when mobile sidebar is closed
            document.body.style.overflow = '';
            
            updateSidebarIcon('closed');
          } else {
            sidebarElements.sidebar.style.display = 'none';
            sidebarElements.appContainer.style.gridTemplateColumns = '1fr';
            sidebarElements.appContainer.style.gridTemplateAreas = '"header" "main"';
            updateSidebarIcon('closed');
          }
        }
      });
    });

    function setupApiKeyHeadersToggles() {
      document.querySelectorAll('.api-key-header').forEach(header => {
        header.addEventListener('click', function() {
          const instructions = this.nextElementSibling;
          const icon = this.querySelector('i');
          
          if (!instructions || !instructions.classList.contains('api-key-instructions')) {
            console.error('Could not find instructions element', instructions);
            return;
          }

          const isVisible = window.getComputedStyle(instructions).display !== 'none';
          
          instructions.style.display = isVisible ? 'none' : 'block';
          icon.className = isVisible ? 'ri-arrow-down-s-line' : 'ri-arrow-up-s-line';
        });
      });
      
      document.querySelectorAll('.api-key-instructions').forEach(instructions => {
        instructions.style.display = 'none';
      });
    }
    
    // Load saved API keys from cache
    function loadSavedApiKeys() {
      document.getElementById('api_key_cloud').value = apiKeyCache.get('openaiApiKey') || '';
      document.getElementById('deepgram_api_key').value = apiKeyCache.get('deepgramApiKey') || '';
      document.getElementById('gladia_api_key').value = apiKeyCache.get('gladiaApiKey') || '';
      document.getElementById('elevenlabs_api_key').value = apiKeyCache.get('elevenlabsApiKey') || '';
    }

    // File Handling
    const handleFileSelection = (e) => processSelectedFiles(e.target.files);
    const handleFileDrop = (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover'); processSelectedFiles(e.dataTransfer.files); };
    const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.add('dragover'); };
    const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover'); };

    async function uploadExampleFile() {
      try {
        // Fetch audio file
        const audioResponse = await fetch('https://files.catbox.moe/xu2kk6.mp3');
        
        if (!audioResponse.ok) {
          throw new Error('Failed to fetch example audio file');
        }
        
        const audioBlob = await audioResponse.blob();
        
        // Create audio file
        const audioFile = new File([audioBlob], 'example-audio.mp3', { type: 'audio/mpeg' });
        const fileList = new DataTransfer();
        fileList.items.add(audioFile);
        
        // Process the audio file first
        processSelectedFiles(fileList.files);
        
        // Embedded SRT content (to avoid CORS issues)
        const srtText = `1
00:00:01,139 --> 00:00:07,879
JR

2
00:00:07,879 --> 00:00:11,380


3
00:00:11,659 --> 00:00:14,638


4
00:00:14,638 --> 00:00:23,978


5
00:00:23,978 --> 00:00:32,097


6
00:00:32,097 --> 00:00:37,679


7
00:00:37,679 --> 00:00:41,439


8
00:00:41,439 --> 00:00:44,618
`;

        const segments = parseTranscriptContent(srtText, 'srt');
        const transcriptData = buildAllTranscriptFormats(segments);
        
        // Select scribe-v1 model and switch to cloud tab
        const scribeV1Radio = document.getElementById('scribe-v1');
        if (scribeV1Radio) {
          scribeV1Radio.checked = true;
          switchModelTab('cloud');
          handleModelSelection();
        }
        
        // Wait a moment for file processing, then add the transcript result
        setTimeout(() => {
          // Find the example file in the queue (it should be the last added file)
          const exampleFile = fileQueue.find(f => f.name === 'example-audio.mp3');
          const targetFileId = exampleFile ? exampleFile.id : currentActiveFile;
          
          if (targetFileId) {
            const mockResult = {
              fileName: 'example-audio.mp3',
              model: 'scribe-v1',
              task: 'transcribe',
              language: 'auto-detected',
              ...transcriptData,
              elapsed_time: 0
            };
            
            // Store the result
            setFileTranscription(targetFileId, 'scribe-v1', mockResult);
            
            // Ensure this file is selected
            currentActiveFile = targetFileId;
            
            // Update UI
            updateModelCompletionStatus(targetFileId);
            showFileResult(targetFileId);
            updateTranscriptionStats(transcriptData.default_transcript, 0);
            updateFileQueue(); // Refresh file list to show completion status
          }
          showToast('success', 'Example Loaded', 'Japanese train announcement example loaded with transcript!');
        }, 500);
        
      } catch (error) {
        console.error('Error fetching example files:', error);
        showToast('error', 'Example Failed', 'Could not load example file. Please check your internet connection.');
      }
    }

    function handleTranscriptUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Check if file type is supported
        const fileExtension = file.name.toLowerCase().split('.').pop();
        if (!['srt', 'vtt', 'tsv', 'txt'].includes(fileExtension)) {
            showToast('error', 'Unsupported Format', 'Please upload SRT, VTT, TSV or TXT files only.');
            event.target.value = ''; // Reset input
            return;
        }
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const format = detectTranscriptFormat(file.name, content);
            const segments = parseTranscriptContent(content, format);
            
            if (segments.length === 0) {
                showToast('error', 'Invalid Format', 'Could not parse the transcript file.');
                return;
            }
            
            // Create transcript data from uploaded content
            const transcriptData = buildAllTranscriptFormats(segments);
            
            // Create a mock file result for the uploaded transcript
            const mockFileResult = {
                fileName: file.name,
                model: 'uploaded',
                task: 'upload',
                language: 'auto',
                elapsed_time: 0,
                ...transcriptData
            };
            
            // If there's a current active file, use it; otherwise create a placeholder
            let targetFileId = currentActiveFile;
            if (!targetFileId) {
                // Create a placeholder file entry
                const placeholderFile = {
                    id: 'uploaded_' + Math.random().toString(36).substr(2, 9),
                    name: file.name,
                    size: file.size,
                    type: 'text/plain',
                    selected: true
                };
                fileQueue.push(placeholderFile);
                targetFileId = placeholderFile.id;
                currentActiveFile = targetFileId;
                updateFileQueue();
            }
            
            // Store the uploaded transcript
            setFileTranscription(targetFileId, 'uploaded', mockFileResult);
            
            showFileResult(targetFileId);
            updateFileQueueItemStatusById(targetFileId, '', true);
            updateModelCompletionStatus(targetFileId);
            
            // Switch to appropriate tab based on format
            if (format === 'srt') switchTab('srt');
            else if (format === 'vtt') switchTab('vtt');
            else if (format === 'tsv') switchTab('tsv');
            else switchTab('default');
            
            showToast('success', 'Transcript Uploaded', `Successfully loaded ${segments.length} segments from ${file.name}`);
        };
        
        reader.onerror = function() {
            showToast('error', 'Upload Failed', 'Could not read the transcript file.');
        };
        
        reader.readAsText(file);
        event.target.value = ''; // Reset input
    }

    function processSelectedFiles(fileList) {
        if (!fileList || fileList.length === 0) return;

        domCache.progressContainer.classList.add('active'); // Show progress briefly
        progressBar.style.width = "100%";
        progressPercent.textContent = "100%";
        setTimeout(() => domCache.progressContainer.classList.remove('active'), 500);

        let lastAddedFileId = null;
        let filesAddedCount = 0;
        Array.from(fileList).forEach(file => {
            if (!file.type.startsWith('audio/') && !file.type.startsWith('video/')) {
                 console.warn(`Skipping unsupported file type: ${file.name} (${file.type})`);
                 showToast('warning', 'Unsupported File', `${file.name} has an unsupported type.`);
                 return;
            }
             if (file.size > 1024 * 1024 * 1024) {
                 console.warn(`Skipping large file: ${file.name} (${formatFileSize(file.size)})`);
                 showToast('warning', 'File Too Large', `${file.name} exceeds the 1GB size limit.`);
                 return;
            }

            file.id = 'file_' + Math.random().toString(36).substr(2, 9);
            file.selected = true;
            clearFileCache(file.id);
            fileQueue.push(file);
            lastAddedFileId = file.id;
            filesAddedCount++;
        });

        updateFileQueue(); // Update UI list


        if (lastAddedFileId) {
            currentActiveFile = lastAddedFileId;
             const lastFile = fileQueue.find(f => f.id === lastAddedFileId);
             if (lastFile) showFilePreview(lastFile);
            updateFileQueue(); // Update again to show selection highlight
        } else if (fileQueue.length > 0 && !currentActiveFile) {
             currentActiveFile = fileQueue[0].id;
             showFilePreview(fileQueue[0]);
             updateFileQueue();
        }

        clearQueueBtn.disabled = fileQueue.length === 0;
        selectAllFilesBtn.disabled = fileQueue.length === 0;
        updateTranscribeButtonText();
    }

    // Tab Management
    function switchModelTab(tabName) {
      if (!modelElements.tabButtons || !modelElements.tabContents) return;

      modelElements.tabButtons.forEach(btn => btn.classList.remove('active'));
      const targetButton = tabName === 'local' ? modelElements.localTabButton : modelElements.cloudTabButton;
      if (targetButton) targetButton.classList.add('active');

      modelElements.tabContents.forEach(content => content.classList.remove('active'));
      const targetContent = tabName === 'local' ? modelElements.localTabContent : modelElements.cloudTabContent;
      if (targetContent) targetContent.classList.add('active');

      updateApiSectionsVisibility();
    }

    function updateApiSectionsVisibility() {
      const selectedModel = getSelectedModel();
      if (!selectedModel) return;
      
      const isOpenAIModel = ['whisper-1', 'gpt-4o-transcribe', 'gpt-4o-mini-transcribe'].includes(selectedModel);
      const isDeepgramModel = selectedModel === 'nova-3';
      const isGladiaModel = selectedModel === 'gladia';
      const isElevenLabsModel = selectedModel === 'scribe-v1';
      const isGPT4oModel = ['gpt-4o-transcribe', 'gpt-4o-mini-transcribe'].includes(selectedModel);
      const isOnLocalTab = modelElements.localTabButton?.classList.contains('active');
      const showApiSections = !isOnLocalTab;

      document.getElementById('openaiApiKeySection').style.display = (isOpenAIModel && showApiSections) ? 'block' : 'none';
      document.getElementById('gpt4o-prompt-section').style.display = (isGPT4oModel && showApiSections) ? 'block' : 'none';
      document.getElementById('deepgramApiKeySection').style.display = (isDeepgramModel && showApiSections) ? 'block' : 'none';
      document.getElementById('gladiaApiKeySection').style.display = (isGladiaModel && showApiSections) ? 'block' : 'none';
      document.getElementById('elevenlabsApiKeySection').style.display = (isElevenLabsModel && showApiSections) ? 'block' : 'none';

      const deepgramOptionsDiv = document.getElementById('deepgramOptions');
      if (deepgramOptionsDiv) {
        isPythonBackendAvailable().then(pythonAvailable => {
          deepgramOptionsDiv.style.display = (isDeepgramModel && showApiSections && pythonAvailable) ? 'block' : 'none';
        });
      }
      

      const priceCalculatorDiv = domCache.priceCalculator;
      if (priceCalculatorDiv) {
        priceCalculatorDiv.style.display = showApiSections ? 'block' : 'none';
      }
    }

    // Server Detection
    async function checkServerAvailability() {
      try {
        if (window.location.protocol === 'file:') {
          serverAvailable = false;
        } else {
          const response = await fetch('/', { 
            method: 'HEAD', 
            timeout: 3000,
            signal: AbortSignal.timeout(3000)
          });
          serverAvailable = response.ok;
        }
      } catch (error) {
        serverAvailable = false;
      }
      serverCheckComplete = true;
      updateUIBasedOnServerAvailability();
      console.log('Server available:', serverAvailable);
    }

    function updateUIBasedOnServerAvailability() {
      const localTabButton = modelElements.localTabButton;
      const localTabContent = modelElements.localTabContent;
      const localNotice = document.getElementById('localModelsNotice');
      const localModelInputs = document.querySelectorAll('#localTabContent input[type="radio"]');
      
      if (serverAvailable) {
        // Enable local models tab and content
        localTabButton.classList.remove('disabled');
        localTabContent.classList.remove('disabled');
        localNotice.style.display = 'none';
        localModelInputs.forEach(input => input.disabled = false);
      } else {
        // Keep tab clickable but disable model content and show notice
        localTabButton.classList.remove('disabled'); // Tab remains clickable
        localTabContent.classList.add('disabled'); // Content shows as disabled
        localNotice.style.display = 'block';
        localModelInputs.forEach(input => input.disabled = true);
        
        // Switch to a cloud model if currently on local model
        const currentModel = getSelectedModel();
        if (currentModel && ['tiny', 'base', 'small', 'medium', 'large', 'large-v2', 'large-v3', 'turbo'].includes(currentModel)) {
          document.getElementById('whisper-1').checked = true;
          handleModelSelection();
        }
      }
    }



    // Socket Communication
    function connectSocket() {
      if (!serverAvailable) {
        console.log('Server not available, skipping socket connection');
        return;
      }
      
      if (socket && socket.connected) {
        const currentJobId = document.getElementById('job_id').value;
        socket.emit('join', { job_id: currentJobId });
        console.log("Socket already connected. Re-joining room:", currentJobId);
        return;
      }
      socket = io({ reconnection: true, reconnectionAttempts: 5, reconnectionDelay: 1000, reconnectionDelayMax: 5000, timeout: 20000 });
      socket.on('connect', () => {
        console.log('Connected to server socket.io');
        serverAvailable = true;
        updateUIBasedOnServerAvailability();
        const currentJobId = document.getElementById('job_id').value;
        socket.emit('join', { job_id: currentJobId });
      });
      socket.on('connect_error', (error) => { 
        console.error('Connection error:', error);
        serverAvailable = false;
        updateUIBasedOnServerAvailability();
      });
      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        serverAvailable = false;
        updateUIBasedOnServerAvailability();
      });
      socket.on('joined', (data) => console.log('Joined room:', data.job_id));
      setupSocketListeners();
    }

    function setupSocketListeners() {
      socket.off('progress_update').on('progress_update', (data) => {
        const currentJobId = document.getElementById('job_id').value;
        if (data.job_id === currentJobId) {
          console.log('Progress:', data.progress, data.message);
          updateProgress(data.progress, data.message || 'Processing...');
          if (currentProcessingIndex >= 0 && currentProcessingIndex < activeProcessingQueue.length) {
            const fileId = activeProcessingQueue[currentProcessingIndex]?.id; // Safe access
            if (fileId) updateFileQueueItemStatusById(fileId, `Processing: ${data.progress}%`);
          }
          if (data.progress < 100 && generationInProgress) {
            transcribeButton.innerHTML = '<i class="ri-stop-circle-line"></i><span>Cancel</span>';
          }
        }
      });

      socket.off('transcription_complete').on('transcription_complete', (data) => {
        console.log('Received transcription_complete:', data.job_id, data.model_option);
        const currentJobId = document.getElementById('job_id').value;
        if (data.job_id === currentJobId) {
          if (currentProcessingIndex >= 0 && currentProcessingIndex < activeProcessingQueue.length) {
            const currentFile = activeProcessingQueue[currentProcessingIndex];
            if (currentFile && currentFile.id) { // Check if currentFile and its id exist
      
              // Store results (both current view and persistent)
              const resultData = {
                fileName: currentFile.name, model: data.model_option, task: "transcribe",
                language: data.language || "Unknown",
                summary_text: data.summary_text || null, topics_data: data.topics_data || null,
                srt_text: data.srt_text, default_transcript: data.default_transcript,
                numbered_transcript: data.numbered_transcript, vtt_text: data.vtt_text,
                tsv_text: data.tsv_text, tsv_plain: data.tsv_plain, plain_srt: data.plain_srt,
                elapsed_time: data.elapsed_time // Store elapsed time
              };
              setFileTranscription(currentFile.id, data.model_option, resultData);

              updateFileQueueItemStatusById(currentFile.id, '', true); // Mark as completed in UI
              updateModelCompletionStatus(currentFile.id); // Update model done badges

              if (currentActiveFile === currentFile.id) { // If this is the selected file, show results
                showFileResult(currentFile.id);
                 updateTranscriptionStats(resultData.default_transcript, resultData.elapsed_time);
              }
              if (document.getElementById('notifyToggle').checked) { showBrowserNotification(`Transcription Complete`, `${currentFile.name} processed.`); }

              progressBar.style.width = "0%"; progressPercent.textContent = "0%"; // Reset progress bar
              setTimeout(processNextFileInQueue, 300); // Move to next file
            } else { console.warn("Completed event received but current file invalid in active queue."); processNextFileInQueue(); }
          } else { console.warn("Completed event received but currentProcessingIndex is invalid."); processNextFileInQueue(); }
        } else { console.log(`Ignoring completion for different job: ${data.job_id}`); }
      });

      socket.off('transcription_failed').on('transcription_failed', (data) => {
         const currentJobId = document.getElementById('job_id').value;
         if (data.job_id === currentJobId) {
            console.error('Transcription failed:', data.error);
            showToast('error', 'Transcription Failed', data.error);
            if (currentProcessingIndex >= 0 && currentProcessingIndex < activeProcessingQueue.length) {
                const fileId = activeProcessingQueue[currentProcessingIndex]?.id; // Safe access
                 if (fileId) {
                     updateFileQueueItemStatusById(fileId, 'Failed');
                     const fileInQueue = fileQueue.find(f => f.id === fileId);
                     if(fileInQueue) fileInQueue.error = true; // Mark file as errored
                 }
            }
            generationInProgress = false; // Ensure processing stops on failure
            setTimeout(processNextFileInQueue, 500); // Try next file after failure
         }
      });

      socket.off('transcription_cancelled').on('transcription_cancelled', (data) => {
        const currentJobId = document.getElementById('job_id').value;
        if (data.job_id === currentJobId) {
            console.log('Transcription cancelled by server for job:', data.job_id);
            showToast('info', 'Transcription Cancelled', 'Process stopped.');
            if (currentProcessingIndex >= 0 && currentProcessingIndex < activeProcessingQueue.length) {
                const fileId = activeProcessingQueue[currentProcessingIndex]?.id; // Safe access
                if (fileId) {
                    updateFileQueueItemStatusById(fileId, 'Cancelled');
                    const fileInQueue = fileQueue.find(f => f.id === fileId);
                    if(fileInQueue) {
                        updateFileQueue();
                    }
                }
            }
            resetTranscriptionUI(); // Fully reset UI and stop queue
         }
      });
    }

    // --- UI Update Functions ---
    function updateFileQueue() {
        const queueElement = document.getElementById('fileQueue'); queueElement.innerHTML = '';
        fileCountEl.textContent = `${fileQueue.length} ${fileQueue.length === 1 ? 'file' : 'files'}`;
        const showCheckboxes = fileQueue.length > 1;
        
        // Toggle dropzone condensed state based on file count
        const dropzone = document.getElementById('dropZone');
        if (fileQueue.length > 0) {
            dropzone.classList.add('condensed');
        } else {
            dropzone.classList.remove('condensed');
        }

        fileQueue.forEach((file, index) => {
            const fileItem = document.createElement('div'); fileItem.className = 'file-item';
            if (currentActiveFile === file.id) fileItem.classList.add('selected');
            if (file.error) fileItem.classList.add('failed'); // Use a class for visual indication
            else if (getCompletedModels(file.id).length > 0) fileItem.classList.add('completed');

            const isProcessingThisFile = generationInProgress && activeProcessingQueue[currentProcessingIndex]?.id === file.id;
            if (isProcessingThisFile) fileItem.classList.add('processing');

            fileItem.dataset.index = index; fileItem.dataset.fileId = file.id;

            fileItem.onclick = function() {
                currentActiveFile = file.id;
                updateFileQueue(); // Update selection highlight
                showFilePreview(file);
                updateModelCompletionStatus(file.id);
                const currentModel = getSelectedModel();
                const transcription = getFileTranscription(file.id, currentModel);
                if (transcription) {
                    showFileResult(file.id);
                } else {
                    clearTranscriptDisplay();
                    resetTranscriptionStats();
                }
                updatePriceCalculator();
            };

            const checkboxContainer = document.createElement('div'); checkboxContainer.className = 'file-checkbox';

            if (showCheckboxes) {
                const checkboxBtn = document.createElement('button');
                checkboxBtn.style.background = 'none';
                checkboxBtn.style.border = 'none';
                checkboxBtn.style.padding = '0';
                checkboxBtn.style.width = '18px';
                checkboxBtn.style.height = '18px';
                checkboxBtn.style.cursor = 'pointer';

                const checkboxVisual = document.createElement('div');
                checkboxVisual.style.width = '18px';
                checkboxVisual.style.height = '18px';
                checkboxVisual.style.border = `2px solid var(--border-color)`;
                checkboxVisual.style.borderRadius = '4px';
                checkboxVisual.style.display = 'flex';
                checkboxVisual.style.alignItems = 'center';
                checkboxVisual.style.justifyContent = 'center';
                checkboxVisual.style.transition = 'var(--transition)';

                if (file.selected !== false) {
                    checkboxVisual.style.backgroundColor = 'var(--primary-color)';
                    checkboxVisual.style.borderColor = 'var(--primary-color)';
                    checkboxVisual.innerHTML = '<i class="ri-check-line" style="color: white; font-size: 12px;"></i>';
                }

                // Add hover effect to clearly show it's clickable
                checkboxBtn.onmouseover = function() {
                    checkboxVisual.style.borderColor = 'var(--primary-color)';
                    this.style.cursor = 'auto';
                };

                checkboxBtn.onmouseout = function() {
                    if (file.selected === false) {
                        checkboxVisual.style.borderColor = 'var(--border-color)';
                    }
                };

                checkboxBtn.appendChild(checkboxVisual);

                // Click handler
                checkboxBtn.onclick = function(e) {
                    e.stopPropagation();
                    file.selected = !file.selected;
                    
                    if (file.selected && file.error) {
                        delete file.error;
                    }
                    
                    updateFileQueue();
                    updateTranscribeButtonText();
                };

                checkboxContainer.appendChild(checkboxBtn);
            }

            const fileIcon = document.createElement('div');
            fileIcon.className = 'file-icon';
            if (file.type.startsWith('video/')) {
                fileIcon.innerHTML = '<i class="ri-file-video-line"></i>';
            } else {
                fileIcon.innerHTML = '<i class="ri-file-music-line"></i>';
            }

            const contentContainer = document.createElement('div'); contentContainer.className = 'file-info';
            const nameElement = document.createElement('div'); nameElement.className = 'file-name'; nameElement.textContent = file.name;
            const statusElement = document.createElement('div'); statusElement.className = 'file-meta';
            const sizeSpan = document.createElement('span'); sizeSpan.textContent = formatFileSize(file.size); statusElement.appendChild(sizeSpan);

            let statusBadgeText = ''; let statusBadgeClass = '';
            if (file.error) { statusBadgeText = 'Failed'; statusBadgeClass = 'failed'; }
            else if (isProcessingThisFile) { statusBadgeText = 'Processing'; statusBadgeClass = 'processing'; }
            else if (getCompletedModels(file.id).length > 0) { statusBadgeText = 'Completed'; statusBadgeClass = 'completed'; }
            else if (generationInProgress && activeProcessingQueue.some(f => f.id === file.id)) { statusBadgeText = 'Queued'; statusBadgeClass = 'idle'; }

            if (statusBadgeText) { const statusBadge = document.createElement('span'); statusBadge.className = `file-status ${statusBadgeClass}`; statusBadge.textContent = statusBadgeText; statusElement.appendChild(statusBadge); }

            contentContainer.appendChild(nameElement); contentContainer.appendChild(statusElement);

            const modelsContainer = document.createElement('div'); modelsContainer.className = 'file-models';
            const completedModels = getCompletedModels(file.id);
            if (completedModels.length > 0) { completedModels.forEach(model => { const modelTag = document.createElement('span'); modelTag.className = 'file-model'; modelTag.textContent = model; modelsContainer.appendChild(modelTag); }); }

            const removeButton = document.createElement('button'); removeButton.className = 'file-actions'; removeButton.innerHTML = '<i class="ri-close-line"></i>'; removeButton.onclick = (e) => { e.stopPropagation(); removeFileFromQueue(index); };

            fileItem.appendChild(checkboxContainer); fileItem.appendChild(fileIcon); fileItem.appendChild(contentContainer); fileItem.appendChild(modelsContainer); fileItem.appendChild(removeButton);

            queueElement.appendChild(fileItem);
        });
        updateTranscribeButtonText();
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const units = ['B', 'KB', 'MB', 'GB'];
        let i = 0;
        while (bytes >= 1024 && i < units.length - 1) { bytes /= 1024; i++; }
        return `${bytes.toFixed(1)} ${units[i]}`;
    }

    function updateFileQueueItemStatusById(fileId, statusText, isCompleted = false) {
        const queueItem = document.querySelector(`.file-item[data-file-id="${fileId}"]`);
        if (!queueItem) return;
        queueItem.classList.remove('processing', 'completed', 'failed'); // Clear old status classes
        const statusElement = queueItem.querySelector('.file-meta');
        if (!statusElement) return;
        let statusBadge = statusElement.querySelector('.file-status');

        // Ensure badge exists if statusText or isCompleted is true
        if (!statusBadge && (statusText || isCompleted)) {
            statusBadge = document.createElement('span');
            statusBadge.className = 'file-status';
            // Append after the size span if possible
            const sizeSpan = statusElement.querySelector('span:not(.file-status)');
            if (sizeSpan && sizeSpan.nextSibling) {
                 statusElement.insertBefore(statusBadge, sizeSpan.nextSibling);
            } else {
                 statusElement.appendChild(statusBadge);
            }
        } else if (statusBadge && !statusText && !isCompleted) {
            statusBadge.remove();
        } else if (!statusBadge && isCompleted) { // Case where it was idle and now completed
            statusBadge = document.createElement('span');
            statusBadge.className = 'file-status';
             const sizeSpan = statusElement.querySelector('span:not(.file-status)');
             if (sizeSpan && sizeSpan.nextSibling) {
                  statusElement.insertBefore(statusBadge, sizeSpan.nextSibling);
             } else {
                  statusElement.appendChild(statusBadge);
             }
        }

         if (!statusBadge && !isCompleted) return; // Exit if no badge and not completed

        // Update badge content and item class (only if badge exists)
        if(statusBadge){
             if (isCompleted) { statusBadge.className = 'file-status completed'; statusBadge.textContent = 'Completed'; queueItem.classList.add('completed'); }
             else if (statusText === 'Failed') { statusBadge.className = 'file-status failed'; statusBadge.textContent = 'Failed'; queueItem.classList.add('failed'); }
             else if (statusText === 'Cancelled') { statusBadge.className = 'file-status failed'; statusBadge.textContent = 'Cancelled'; queueItem.classList.add('failed'); } // Visually treat like failed
             else if (statusText.startsWith('Processing')) { statusBadge.className = 'file-status processing'; statusBadge.textContent = 'Processing'; queueItem.classList.add('processing'); }
             else if (statusText === 'Queued') { statusBadge.className = 'file-status idle'; statusBadge.textContent = 'Queued'; }
             else if (statusText) { statusBadge.className = 'file-status idle'; statusBadge.textContent = statusText; } // Generic status like 'Idle'
             else { statusBadge.remove(); }
        }


        if (isCompleted && getCompletedModels(fileId).length > 0) { updateModelTags(queueItem, fileId); } // Update model tags only on completion
    }

     function updateModelTags(queueItem, fileId){
         const modelsContainer = queueItem.querySelector('.file-models');
         const completedModels = getCompletedModels(fileId);
         if (modelsContainer && completedModels.length > 0) {
             modelsContainer.innerHTML = ''; // Clear existing
             // Sort models for consistent display (optional)
             const sortedModels = [...completedModels].sort();
             sortedModels.forEach(model => {
                 const modelTag = document.createElement('span'); modelTag.className = 'file-model';
                 // Map internal model ID to display name if needed
                 modelTag.textContent = model.replace('_', '-'); // Example mapping
                 modelsContainer.appendChild(modelTag);
             });
         }
     }

    // --- Queue Management ---
    function removeFileFromQueue(index) {
        const fileToRemove = fileQueue[index]; if (!fileToRemove) return;
        const fileId = fileToRemove.id;
        if (generationInProgress && activeProcessingQueue[currentProcessingIndex]?.id === fileId) {
            cancelCurrentTranscription(); // Stop backend if this file is running
            // Don't proceed with removal immediately, let cancel handler manage queue state
            return;
        }

        proceedWithRemoval(index, fileId);
    }

    function proceedWithRemoval(index, fileId){

        if(index >= 0 && index < fileQueue.length && fileQueue[index].id === fileId){
             fileQueue.splice(index, 1);
        } else {
             // If index is wrong (e.g., due to race condition), find by ID
             const idxById = fileQueue.findIndex(f => f.id === fileId);
             if (idxById > -1) fileQueue.splice(idxById, 1);
        }


        const activeQueueIndex = activeProcessingQueue.findIndex(f => f.id === fileId);
        if (activeQueueIndex > -1) {
            activeProcessingQueue.splice(activeQueueIndex, 1);
            // Adjust currentProcessingIndex if removing an item before or at the current one
            if (activeQueueIndex <= currentProcessingIndex) {
                currentProcessingIndex--;
            }
        }

        clearFileCache(fileId); // Clean data

        // Clean up preview if this was the previewed file
        if (currentPreviewedFile?.id === fileId) {
            cleanupPreview();
        }

        if (currentActiveFile === fileId) { // Handle selection change
            if (fileQueue.length > 0) {
                // Select the previous file, or the first if removing the first
                 const newIndex = Math.max(0, index - 1); // Adjust potential new index
                 currentActiveFile = fileQueue[newIndex]?.id || fileQueue[0]?.id; // Fallback to first if previous doesn't exist or index was 0
                 const nextActiveFile = fileQueue.find(f => f.id === currentActiveFile);
                if(nextActiveFile){
                     showFilePreview(nextActiveFile); updateModelCompletionStatus(currentActiveFile);
                     const currentModel = getSelectedModel();
                     const transcription = getFileTranscription(currentActiveFile, currentModel);
                     if (transcription) { // Check for results for *selected* model
                          showFileResult(currentActiveFile);
                     } else { clearTranscriptDisplay(); resetTranscriptionStats(); }
                } else { // Should not happen if fileQueue.length > 0, but safety check
                    currentActiveFile = null; clearTranscriptDisplay(); resetTranscriptionStats(); updateModelCompletionStatus(null);
                    previewPlayer.style.display = 'none'; audioPlayerContainer.style.display = 'none'; currentFileDuration = 0;
                }

            } else { // Queue empty
                currentActiveFile = null; clearTranscriptDisplay(); resetTranscriptionStats(); updateModelCompletionStatus(null);
                previewPlayer.style.display = 'none'; audioPlayerContainer.style.display = 'none'; currentFileDuration = 0;
            }
        }
        updateFileQueue(); clearQueueBtn.disabled = fileQueue.length === 0; selectAllFilesBtn.disabled = fileQueue.length === 0; updatePriceCalculator();
    }

    function clearQueue() {
        if (generationInProgress) cancelCurrentTranscription();
        cleanupPreview(); // Clean up current preview before clearing queue
        fileQueue = []; activeProcessingQueue = []; currentProcessingIndex = -1; clearAllFileCache();
        currentActiveFile = null; currentFileDuration = 0;
        clearTranscriptDisplay(); resetTranscriptionStats(); previewPlayer.style.display = 'none';
        audioPlayerContainer.style.display = 'none'; updateFileQueue(); clearQueueBtn.disabled = true; selectAllFilesBtn.disabled = true; updateModelCompletionStatus(null); updatePriceCalculator();
        showToast('info', 'Queue Cleared', 'All files removed.');
    }
    function selectAllFiles() {
        const allSelected = fileQueue.every(file => file.selected !== false);
        fileQueue.forEach(file => {
            file.selected = !allSelected;
            if (file.selected && file.error) {
                delete file.error;
            }
        });
        updateFileQueue(); updateTranscribeButtonText();
    }

    // --- Python Backend Detection ---
    let pythonBackendAvailable = null; // Cache the result
    
    async function isPythonBackendAvailable() {
      if (pythonBackendAvailable !== null) {
        return pythonBackendAvailable;
      }
      
      try {
        // Try to reach a simple backend endpoint
        const response = await fetch('/transcribe_deepgram', {
          method: 'POST',
          body: new FormData() // Empty form data just to test endpoint
        });
        
        // If we get any response (even an error), the backend is available
        pythonBackendAvailable = true;
        console.log('Python backend detected: Available');
      } catch (error) {
        // If fetch fails completely, we're likely on file:// protocol
        pythonBackendAvailable = false;
        console.log('Python backend detected: Not available (likely file:// protocol)');
      }
      
      return pythonBackendAvailable;
    }

    // --- Direct Cloud API Functions ---
    async function transcribeWithCloudAPI(file, selectedModel) {
      const apiKey = getApiKeyForModel(selectedModel);
      if (!apiKey) {
        throw new Error(`API key missing for ${selectedModel}`);
      }

      switch(selectedModel) {
        case 'whisper-1':
          return await transcribeWithOpenAI(file, apiKey, selectedModel);
        case 'gpt-4o-transcribe':
        case 'gpt-4o-mini-transcribe':
          return await transcribeWithOpenAI(file, apiKey, selectedModel);
        case 'nova-3':
          return await transcribeWithDeepgram(file, apiKey);
        case 'gladia':
          return await transcribeWithGladia(file, apiKey);
        case 'scribe-v1':
          return await transcribeWithElevenLabs(file, apiKey);
        default:
          throw new Error(`Direct API not implemented for ${selectedModel}`);
      }
    }

    function getApiKeyForModel(selectedModel) {
      let apiKey = null;
      switch(selectedModel) {
        case 'whisper-1':
        case 'gpt-4o-transcribe':
        case 'gpt-4o-mini-transcribe':
          apiKey = document.getElementById('api_key_cloud').value.trim();
          break;
        case 'nova-3':
          apiKey = document.getElementById('deepgram_api_key').value.trim();
          break;
        case 'gladia':
          apiKey = document.getElementById('gladia_api_key').value.trim();
          break;
        case 'scribe-v1':
          apiKey = document.getElementById('elevenlabs_api_key').value.trim();
          break;
        default:
          return null;
      }
      
      // Additional validation for empty or whitespace-only keys
      if (apiKey && apiKey.length === 0) {
        console.warn(`Empty API key detected for model: ${selectedModel}`);
        return null;
      }
      
      return apiKey;
    }

    async function transcribeWithOpenAI(file, apiKey, model) {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('model', model === 'whisper-1' ? 'whisper-1' : model);
      formData.append('response_format', 'verbose_json');

      const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`
        },
        body: formData
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: { message: `HTTP ${response.status}` } }));
        throw new Error(error.error?.message || `OpenAI API error: ${response.status}`);
      }

      return await response.json();
    }

    async function transcribeWithDeepgram(file, apiKey) {
      const response = await fetch('https://api.deepgram.com/v1/listen?model=nova-3&language=multi&diarize=true&punctuate=true&paragraphs=true&utterances=true&smart_format=true', {
        method: 'POST',
        headers: {
          'Authorization': `Token ${apiKey}`,
          'Content-Type': file.type
        },
        body: file
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
        throw new Error(error.error || `Deepgram API error: ${response.status}`);
      }

      return await response.json();
    }



    async function transcribeWithGladiaProxy(file, apiKey) {

      
      // Use the existing backend endpoint that already works
      const formData = new FormData();
      formData.append('file', file);
      formData.append('gladia_api_key', apiKey);
      formData.append('job_id', 'direct_' + Date.now());
      

      
      const response = await fetch('/transcribe_gladia', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
        throw new Error(error.error || `Backend proxy error: ${response.status}`);
      }
      
      const result = await response.json();

      return {
        status: 'done',
        result: {
          transcription: {
            full_transcript: 'Transcription will be handled by backend - check the main interface for results'
          }
        }
      };
    }

    async function transcribeWithGladia(file, apiKey) {

      
      // Validate API key
      if (!apiKey || apiKey.length < 10) {
        throw new Error('Invalid Gladia API key: key is missing or too short');
      }
      
      // Add small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const uploadFormData = new FormData();
      uploadFormData.append('audio', file, file.name);
      

      const trimmedKey = apiKey.trim();
      
      const uploadResponse = await fetch('https://api.gladia.io/v2/upload', {
        method: 'POST',
        headers: {
          'x-gladia-key': trimmedKey
          // Note: Don't set Content-Type for FormData - browser sets multipart/form-data with boundary automatically
        },
        body: uploadFormData
      });


      
      if (!uploadResponse.ok) {
        const errorText = await uploadResponse.text().catch(() => 'No error details');
        console.error('Upload error details:', errorText);
        console.error('Upload response status:', uploadResponse.status);
        console.error('Upload response headers:', Object.fromEntries(uploadResponse.headers.entries()));
        
        let errorObj;
        try {
          errorObj = JSON.parse(errorText);
        } catch {
          errorObj = { error: errorText };
        }
        
        // Handle specific authentication errors
        if (uploadResponse.status === 401) {
          throw new Error('Authentication failed: Invalid Gladia v2 API key. Please check your API key in settings.');
        }
        
        throw new Error(errorObj.error || errorObj.message || `Gladia v2 upload error: ${uploadResponse.status}`);
      }

      const uploadResult = await uploadResponse.json();
      const audioUrl = uploadResult.audio_url;

       const requestBody = {
         audio_url: audioUrl,
         language_config: {
           languages: [],
           code_switching: false
         }
       };

      const transcribeResponse = await fetch('https://api.gladia.io/v2/pre-recorded', {
        method: 'POST',
        headers: {
          'x-gladia-key': apiKey.trim(),
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });



      if (!transcribeResponse.ok) {
        const errorText = await transcribeResponse.text().catch(() => 'No error details');
        console.error('Transcription error details:', errorText);
        let errorObj;
        try {
          errorObj = JSON.parse(errorText);
        } catch {
          errorObj = { error: errorText };
        }
        throw new Error(errorObj.error || errorObj.message || `Gladia v2 transcription error: ${transcribeResponse.status}`);
      }

      const transcribeResult = await transcribeResponse.json();
      const resultUrl = transcribeResult.result_url;

      let pollAttempts = 0;
      const maxAttempts = 60; // 5 minutes max
      let delay = 5000; // Start with 5 second delay

      while (pollAttempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, delay));
        
        const resultResponse = await fetch(resultUrl, {
          headers: {
            'x-gladia-key': apiKey.trim()
          }
        });

        if (!resultResponse.ok) {
          throw new Error(`Gladia v2 result polling error: ${resultResponse.status}`);
        }

        const result = await resultResponse.json();
        
        if (result.status === 'done') {
          return result;
        } else if (result.status === 'error') {
          throw new Error(result.error || 'Gladia transcription failed');
        }
        
        pollAttempts++;
        // Adaptive backoff: increase delay but cap at 15 seconds
        delay = Math.min(delay * 1.2, 15000);
      }

      throw new Error('Gladia v2 transcription timeout');
    }

    async function transcribeWithElevenLabs(file, apiKey) {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('model_id', 'scribe_v1');
      formData.append('output_format', 'json');
      formData.append('response_format', 'verbose_json');
      formData.append('tag_audio_events', 'false');
      
      const response = await fetch('https://api.elevenlabs.io/v1/speech-to-text', {
        method: 'POST',
        headers: {
          'xi-api-key': apiKey.trim()
        },
        body: formData
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
        throw new Error(error.detail?.message || error.error || `ElevenLabs API error: ${response.status}`);
      }

      return await response.json();
    }

    function handleDirectAPIResult(file, selectedModel, result) {
      try {
        updateProgress(80, 'Processing results...');
        
        let segments = [];
        let language = "auto-detected";
        
        // Process different API response formats
        if (selectedModel.includes('whisper') || selectedModel.includes('gpt-4o')) {
          // OpenAI format
          segments = result.segments || [];
          language = result.language || "auto-detected";
          
          if (!segments.length && result.text) {
            // Fallback: create segments from text
            segments = estimateSegmentsFromText(result.text, file);
          }
        } else if (selectedModel === 'nova-3') {
          // Deepgram format
          segments = extractSegmentsFromDeepgramResponse(result);
          language = "multi";
        } else if (selectedModel === 'gladia') {
          // Gladia format
          segments = extractSegmentsFromGladiaResponse(result);
          language = result.transcription?.languages?.[0] || 
                    result.result?.transcription?.languages?.[0] || 
                    result.prediction?.language || 
                    "auto-detected";
        } else if (selectedModel === 'scribe-v1') {
          // ElevenLabs format

          segments = extractSegmentsFromElevenLabsResponse(result);
          language = "auto-detected";
        }
        
        if (!segments.length) {
          segments = [{
            start: 0,
            end: 1,
            text: result.text || "[No transcript available]"
          }];
        }
        
        // Build transcript formats
        const transcriptFormats = buildAllTranscriptFormats(segments);
        
        // Store results
        const resultData = {
          fileName: file.name,
          model: selectedModel,
          task: "transcribe",
          language: language,
          ...transcriptFormats,
          elapsed_time: 0
        };
        
        setFileTranscription(file.id, selectedModel, resultData);
        
        updateProgress(100, 'Complete');
        updateFileQueueItemStatusById(file.id, '', true);
        updateModelCompletionStatus(file.id);
        
        if (currentActiveFile === file.id) {
          showFileResult(file.id);
          updateTranscriptionStats(resultData.default_transcript, resultData.elapsed_time);
        }
        
        showToast('success', 'Transcription Complete', `${file.name} processed successfully.`);
        setTimeout(processNextFileInQueue, 300);
        
      } catch (error) {
        console.error('Error processing direct API result:', error);
        handleApiError(file.id, 'Error processing transcription result');
      }
    }

    // Helper functions for direct API processing
    function estimateSegmentsFromText(text, file) {
      const sentences = text.split(/[.!?]+/).filter(s => s.trim());
      const avgDuration = 3; // seconds per sentence
      
      return sentences.map((sentence, i) => ({
        start: i * avgDuration,
        end: (i + 1) * avgDuration,
        text: sentence.trim()
      }));
    }

    function extractSegmentsFromDeepgramResponse(result) {
      const segments = [];
      if (!result || !result.results) {
        return segments;
      }

      const resultsData = result.results;
      
      // Prefer utterances (matches backend logic)
      if (resultsData.utterances && resultsData.utterances.length > 0) {
        resultsData.utterances.forEach(utt => {
          segments.push({
            start: utt.start || 0,
            end: utt.end || 0,
            text: (utt.transcript || "").trim()
          });
        });
        return segments;
      }

      // Fallback to channels + paragraphs + words (matches backend)
      if (resultsData.channels && resultsData.channels.length > 0) {
        const channel = resultsData.channels[0];
        if (channel.alternatives && channel.alternatives.length > 0) {
          const alt = channel.alternatives[0];
          
          // First try paragraphs if available
          if (alt.paragraphs && alt.paragraphs.paragraphs) {
            alt.paragraphs.paragraphs.forEach(para => {
              segments.push({
                start: para.start || 0,
                end: para.end || 0,
                text: (para.text || "").trim()
              });
            });
            return segments;
          }
          
          // Then try words as a last resort
          if (alt.words && alt.words.length > 0) {
            let currentSegment = null;
            const maxWordsPerSegment = 20;
            const maxGapSeconds = 2.0;
            
            alt.words.forEach(word => {
              const text = (word.word || "").trim();
              const start = word.start;
              const end = word.end;
              
              if (!text || start === undefined || end === undefined) return;
              
              let startNew = false;
              if (!currentSegment) {
                startNew = true;
              } else {
                const gap = start - currentSegment.end;
                const prevEndsSentence = currentSegment.text.endsWith('.') || 
                                       currentSegment.text.endsWith('!') || 
                                       currentSegment.text.endsWith('?');
                if (gap > maxGapSeconds || 
                    currentSegment.wordsInSegment >= maxWordsPerSegment || 
                    prevEndsSentence) {
                  startNew = true;
                }
              }
              
              if (startNew && currentSegment) {
                currentSegment.text = currentSegment.text.trim();
                if (currentSegment.text) {
                  segments.push({
                    start: currentSegment.start,
                    end: currentSegment.end,
                    text: currentSegment.text
                  });
                }
                currentSegment = null;
              }
              
              if (startNew) {
                currentSegment = {
                  start: start,
                  end: end,
                  text: "",
                  wordsInSegment: 0
                };
              }
              
              const needsSpace = currentSegment.text && !currentSegment.text.endsWith(' ');
              currentSegment.text += (needsSpace ? " " : "") + text;
              currentSegment.end = Math.max(currentSegment.end, end);
              currentSegment.wordsInSegment++;
            });
            
            // Add final segment
            if (currentSegment && currentSegment.text.trim()) {
              segments.push({
                start: currentSegment.start,
                end: currentSegment.end,
                text: currentSegment.text.trim()
              });
            }
          }
        }
      }
      
      return segments;
    }

    function extractSegmentsFromGladiaResponse(result) {
      const segments = [];

      
      // Match backend logic: Check for result.transcription.utterances first
      if (result?.result?.transcription?.utterances) {
        result.result.transcription.utterances.forEach(utt => {
          const text = (utt.text || "").trim();
          if (text) {
          segments.push({
            start: utt.start || 0,
            end: utt.end || 0,
              text: text
          });
          }
        });
      } else if (result?.transcription?.utterances) {
        // Alternative structure
        result.transcription.utterances.forEach(utt => {
          const text = (utt.text || "").trim();
          if (text) {
          segments.push({
            start: utt.start || 0,
            end: utt.end || 0,
              text: text
          });
          }
        });
      } else if (result?.prediction?.words) {
        // Word-level timestamps - group into sentences
        let currentSegment = { start: 0, end: 0, text: "" };
        
        result.prediction.words.forEach((word, index) => {
          if (currentSegment.text === "") {
            currentSegment.start = word.start || 0;
          }
          currentSegment.text += (currentSegment.text ? " " : "") + (word.word || word.text || "");
          currentSegment.end = word.end || word.start || 0;
          
          // Break into segments at sentence boundaries or every ~20 words
          if ((word.word && word.word.match(/[.!?]$/)) || (index > 0 && index % 20 === 0)) {
            if (currentSegment.text.trim()) {
              segments.push({
                start: currentSegment.start,
                end: currentSegment.end,
                text: currentSegment.text.trim()
              });
              currentSegment = { start: currentSegment.end, end: currentSegment.end, text: "" };
            }
          }
        });
        
        // Add final segment
        if (currentSegment.text.trim()) {
          segments.push({
            start: currentSegment.start,
            end: currentSegment.end,
            text: currentSegment.text.trim()
          });
        }
      } else if (result?.prediction?.full_transcript || result?.result?.transcription?.full_transcript) {
        // Fallback: create segments from full transcript
        const fullText = result?.prediction?.full_transcript || result?.result?.transcription?.full_transcript;
        return estimateSegmentsFromText(fullText);
      }
      
      return segments;
    }

    function extractSegmentsFromElevenLabsResponse(result) {
      const segments = [];
      
      // Handle different writing systems for optimal transcript segmentation
      if (result?.words) {
        let currentSegment = null;
        const maxGapSeconds = 1.0;
        
        // Detect spaceless writing systems (Chinese, Japanese, Khmer, Lao, Myanmar, Thai, Tibetan)
        const fullText = result.words.map(item => item.text || "").join("");
        const isSpacelessLanguage = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\u0E00-\u0E7F\u1780-\u17FF\u1000-\u109F\u0F00-\u0FFF\u0E80-\u0EFF]/.test(fullText);
        
        const maxWordsPerSegment = isSpacelessLanguage ? 25 : 15;
        const maxCharactersPerSegment = isSpacelessLanguage ? 80 : 200;
        
        result.words.forEach(item => {
          const itemType = item.type;
          const text = (item.text || "").trim();
          const start = item.start;
          const end = item.end;
          
          // Skip spacing items
          if (itemType === "spacing") return;
          if (start === undefined || end === undefined) return;
          
          let startNew = false;
          if (!currentSegment) {
            startNew = true;
          } else {
            const gap = start - currentSegment.end;
            
            const prevEndsSentence = isSpacelessLanguage ? 
              (currentSegment.text.endsWith('') || currentSegment.text.endsWith('') || 
               currentSegment.text.endsWith('') || currentSegment.text.endsWith('') ||
               currentSegment.text.endsWith('') || currentSegment.text.endsWith('') ||
               currentSegment.text.endsWith('') || currentSegment.text.endsWith('')) :
              (currentSegment.text.endsWith('.') || currentSegment.text.endsWith('!') || 
               currentSegment.text.endsWith('?'));
            
            if (isSpacelessLanguage) {
              if (gap > maxGapSeconds || currentSegment.text.length >= maxCharactersPerSegment || prevEndsSentence) {
                startNew = true;
              }
            } else {
              if (gap > maxGapSeconds || currentSegment.wordsInSegment >= maxWordsPerSegment || prevEndsSentence) {
                startNew = true;
              }
            }
          }
          
          if (startNew && currentSegment) {
            currentSegment.text = currentSegment.text.trim();
            if (currentSegment.text) {
              segments.push({
                start: currentSegment.start,
                end: currentSegment.end,
                text: currentSegment.text
              });
            }
            currentSegment = null;
          }
          
          if (startNew) {
            currentSegment = {
              start: start,
              end: end,
              text: "",
              wordsInSegment: 0
            };
          }
          
          const needsSpace = !isSpacelessLanguage && currentSegment.text && !currentSegment.text.endsWith('[');
          currentSegment.text += (needsSpace ? " " : "") + text;
          currentSegment.end = Math.max(currentSegment.end, end);
          currentSegment.wordsInSegment++;
        });
        
        // Add final segment
        if (currentSegment && currentSegment.text.trim()) {
          segments.push({
            start: currentSegment.start,
            end: currentSegment.end,
            text: currentSegment.text.trim()
          });
        }
      } else if (result?.segments) {
        // Segments already provided
        result.segments.forEach(seg => {
          segments.push({
            start: seg.start || 0,
            end: seg.end || 0,
            text: seg.text || ""
          });
        });
      } else if (result?.text) {
        // Plain text response - break into sentences
        const sentences = result.text.split(/(?<=[.!?])\s+/).filter(s => s.trim());
        const avgDuration = 4; // 4 seconds per sentence
        
        sentences.forEach((sentence, i) => {
          segments.push({
            start: i * avgDuration,
            end: (i + 1) * avgDuration,
            text: sentence.trim()
          });
        });
      } else if (result?.transcript) {
        // Fallback: create segments from transcript text
        return estimateSegmentsFromText(result.transcript);
      }
      
      return segments;
    }

    function detectTranscriptFormat(filename, content) {
        const ext = filename.toLowerCase().split('.').pop();
        
        // Check file extension first
        if (ext === 'srt') return 'srt';
        if (ext === 'vtt') return 'vtt';
        if (ext === 'tsv') return 'tsv';
        
        // Check content patterns
        if (content.includes('WEBVTT') || (content.includes('-->') && content.includes('.'))) return 'vtt';
        if (/^\d+\s*\n\d{2}:\d{2}:\d{2},\d{3}\s*-->\s*\d{2}:\d{2}:\d{2},\d{3}/m.test(content)) return 'srt';
        if (content.includes('\t') && content.split('\n')[0].split('\t').length > 2) return 'tsv';
        
        return 'plain'; // Default to plain text
    }

    function parseTranscriptContent(content, format) {
        const segments = [];
        let segmentId = 0;
        
        switch (format) {
            case 'srt':
                const srtBlocks = content.trim().split(/\n\s*\n/);
                srtBlocks.forEach(block => {
                    const lines = block.trim().split('\n');
                    if (lines.length >= 3) {
                        const timeLine = lines[1];
                        const textLines = lines.slice(2).join(' ');
                        const timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2}),(\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}),(\d{3})/);
                        
                        if (timeMatch) {
                            const startTime = parseTimeToSeconds(timeMatch[1], timeMatch[2]);
                            const endTime = parseTimeToSeconds(timeMatch[3], timeMatch[4]);
                            
                            segments.push({
                                id: segmentId++,
                                start: startTime,
                                end: endTime,
                                text: textLines.trim()
                            });
                        }
                    }
                });
                break;
                
            case 'vtt':
                const vttLines = content.split('\n');
                let currentSegment = null;
                
                vttLines.forEach(line => {
                    line = line.trim();
                    if (line.includes('-->')) {
                        const timeMatch = line.match(/(\d{2}:\d{2}:\d{2})\.(\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2})\.(\d{3})/);
                        if (timeMatch) {
                            const startTime = parseTimeToSeconds(timeMatch[1], timeMatch[2]);
                            const endTime = parseTimeToSeconds(timeMatch[3], timeMatch[4]);
                            
                            currentSegment = {
                                id: segmentId++,
                                start: startTime,
                                end: endTime,
                                text: ''
                            };
                        }
                    } else if (currentSegment && line && !line.startsWith('WEBVTT') && !line.startsWith('NOTE')) {
                        currentSegment.text += (currentSegment.text ? ' ' : '') + line;
                    } else if (currentSegment && !line) {
                        // Empty line indicates end of segment
                        if (currentSegment.text.trim()) {
                            segments.push(currentSegment);
                        }
                        currentSegment = null;
                    }
                });
                
                // Add last segment if exists
                if (currentSegment && currentSegment.text.trim()) {
                    segments.push(currentSegment);
                }
                break;
                
            case 'tsv':
                const tsvLines = content.split('\n');
                tsvLines.forEach((line, index) => {
                    if (index === 0) return; // Skip header
                    const columns = line.split('\t');
                    if (columns.length >= 4) {
                        const startTime = parseTimeToSeconds(columns[1]);
                        const endTime = parseTimeToSeconds(columns[2]);
                        
                        segments.push({
                            id: segmentId++,
                            start: startTime,
                            end: endTime,
                            text: columns[3].trim()
                        });
                    }
                });
                break;
                
            default: // plain text
                const paragraphs = content.split(/\n\s*\n/).filter(p => p.trim());
                paragraphs.forEach((paragraph, index) => {
                    segments.push({
                        id: segmentId++,
                        start: index * 5, // Placeholder timing - 5 seconds apart
                        end: (index + 1) * 5,
                        text: paragraph.trim()
                    });
                });
                break;
        }
        
        return segments;
    }

    function parseTimeToSeconds(timeString, millisecondsString = '000') {
        const parts = timeString.split(':');
        const hours = parseInt(parts[0]) || 0;
        const minutes = parseInt(parts[1]) || 0;
        const seconds = parseInt(parts[2]) || 0;
        const milliseconds = parseInt(millisecondsString) || 0;
        
        return hours * 3600 + minutes * 60 + seconds + milliseconds / 1000;
    }

    function buildAllTranscriptFormats(segments) {
      return {
        srt_text: generateSrtFromSegments(segments),
        default_transcript: generateSyncedTranscriptFromSegments(segments),
        numbered_transcript: generateNumberedTranscriptFromSegments(segments),
        vtt_text: generateVttFromSegments(segments),
        tsv_text: generateTsvFromSegments(segments),
        plain_srt: generatePlainSrtFromSegments(segments),
        tsv_plain: generatePlainTsvFromSegments(segments),
        plain_vtt: generatePlainVttFromSegments(segments)
      };
    }

    function formatTime(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      const milliseconds = Math.floor((seconds - Math.floor(seconds)) * 1000);
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
    }

    function generateSyncedTranscriptFromSegments(segments) {
      let output = "";
      segments.forEach(seg => {
        output += `<div class="transcript-segment" data-start="${seg.start}" data-end="${seg.end}">`;
        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
        output += seg.text.trim();
        output += "</div>\n";
      });
      return output.trim();
    }

    function generateNumberedTranscriptFromSegments(segments) {
      let output = "";
      segments.forEach((seg, i) => {
        output += `<div class="transcript-segment" data-start="${seg.start}" data-end="${seg.end}">`;
        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
        output += `<div class="segment-number" style="opacity: 0.5;">${i + 1}</div>`;
        output += `<div class="segment-text">${seg.text.trim()}</div>`;
        output += "</div>\n";
      });
      return output.trim();
    }

    function generateSrtFromSegments(segments) {
      let output = "";
      segments.forEach((seg, i) => {
        const startTime = formatTime(seg.start);
        const endTime = formatTime(seg.end);
        output += `<div class="transcript-segment" data-start="${seg.start}" data-end="${seg.end}">`;
        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
        output += `<div class="srt-index srt-opacity" style="opacity: 0.5;">${i + 1}</div>`;
        output += `<div class="srt-timing srt-opacity" style="opacity: 0.5;">${startTime} --> ${endTime}</div>`;
        output += `<div class="srt-text">${seg.text.trim()}</div>`;
        output += "</div>\n";
      });
      return output.trim();
    }

    function generateVttFromSegments(segments) {
      let output = '<div class="vtt-header">WEBVTT</div>\n';
      segments.forEach(seg => {
        const startTime = formatTime(seg.start).replace(",", ".");
        const endTime = formatTime(seg.end).replace(",", ".");
        output += `<div class="transcript-segment vtt-entry" data-start="${seg.start}" data-end="${seg.end}">`;
        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
        output += `<div class="vtt-timing vtt-opacity" style="opacity: 0.5;">${startTime} --> ${endTime}</div>`;
        output += `<div class="vtt-text">${seg.text.trim()}</div>`;
        output += '</div>\n';
      });
      return output.trim();
    }

    function generateTsvFromSegments(segments) {
      let output = '<table class="tsv-table"><thead><tr><th style="opacity: 0.5;">Segment</th><th style="opacity: 0.5;">Start</th><th style="opacity: 0.5;">End</th><th>Text</th></tr></thead><tbody>';
      segments.forEach((seg, i) => {
        const startTime = formatTime(seg.start);
        const endTime = formatTime(seg.end);
        output += `<tr class="transcript-segment" data-start="${seg.start}" data-end="${seg.end}">`;
        output += `<td style="opacity: 0.5;">${i + 1}</td><td style="opacity: 0.5;">${startTime}</td><td style="opacity: 0.5;">${endTime}</td>`;
        output += `<td>${seg.text.trim()}</td></tr>`;
      });
      output += '</tbody></table>';
      return output;
    }

    // Plain format generators (for proper file downloads)
    function generatePlainSrtFromSegments(segments) {
      let output = "";
      segments.forEach((seg, i) => {
        const startTime = formatTime(seg.start);
        const endTime = formatTime(seg.end);
        output += `${i + 1}\n${startTime} --> ${endTime}\n${seg.text.trim()}\n\n`;
      });
      return output.trim();
    }

    function generatePlainVttFromSegments(segments) {
      let output = "WEBVTT\n\n";
      segments.forEach(seg => {
        const startTime = formatTime(seg.start).replace(",", ".");
        const endTime = formatTime(seg.end).replace(",", ".");
        output += `${startTime} --> ${endTime}\n${seg.text.trim()}\n\n`;
      });
      return output.trim();
    }

    function generatePlainTsvFromSegments(segments) {
      let output = "Segment\tStart\tEnd\tText\n";
      segments.forEach((seg, i) => {
        const startTime = formatTime(seg.start);
        const endTime = formatTime(seg.end);
        output += `${i + 1}\t${startTime}\t${endTime}\t${seg.text.trim()}\n`;
      });
      return output.trim();
    }

    // --- Transcription Process ---
    function handleFormSubmit(e) {
      e.preventDefault(); // Prevent default form submission
      if (generationInProgress) { 
          cancelCurrentTranscription(); 
          return; 
      }
      
      let errorsCleared = false;
      fileQueue.forEach(file => {
          if (file.selected !== false && file.error) {
              delete file.error;
              errorsCleared = true;
          }
      });
      
      if (errorsCleared) {
          updateFileQueue();
      }
      
      activeProcessingQueue = fileQueue.filter(file => file.selected !== false && !file.error);
      if (activeProcessingQueue.length === 0) {
        showToast('warning', 'No Files Ready', fileQueue.some(f=>f.selected) ? 'Selected files have errors or none are selected.' : 'Please select files to transcribe.'); 
        return;
      }
      console.log(`Starting transcription batch for ${activeProcessingQueue.length} selected files.`);
      currentProcessingIndex = -1; 
      isCancelled = false;
      processNextFileInQueue();
}

    function processNextFileInQueue() {
      if (isCancelled) { console.log("Queue stopped by cancellation."); resetTranscriptionUI(); isCancelled = false; return; }
      let nextIndex = -1;
      for (let i = currentProcessingIndex + 1; i < activeProcessingQueue.length; i++) {
          // Find the next file in the active queue that *still exists* in the main fileQueue
          if(fileQueue.some(fq => fq.id === activeProcessingQueue[i].id)) { nextIndex = i; break; }
      }
      if (nextIndex === -1) { console.log('Finished processing batch.'); resetTranscriptionUI(); return; } // Batch done

      // Prep for next file
      document.getElementById('job_id').value = 'job_' + Math.random().toString(36).substr(2, 9); connectSocket(); // New job ID, ensure connection
      currentProcessingIndex = nextIndex;
      const currentFile = activeProcessingQueue[currentProcessingIndex];

      // Select the file in the UI *before* potentially showing preview (which might error)
      currentActiveFile = currentFile.id;
      updateFileQueue();

      showFilePreview(currentFile); // Show preview and update duration/calculator
      updateModelCompletionStatus(currentFile.id);
      console.log(`Processing next: ${currentFile.name} (Index: ${currentProcessingIndex}, Job: ${document.getElementById('job_id').value})`);
      generationInProgress = true; updateTranscribeButtonText(); // Show Cancel
      showStatsLoading(true); // Show loading animation for stats
      clearTranscriptDisplay(); resetTranscriptionStats(); // Clear previous results
      processFile(currentFile); // Call backend
    }

    async function processFile(file) {
        const selectedModel = getSelectedModel();
        const currentJobId = document.getElementById('job_id').value;

        // Start UI animations immediately for all models
        domCache.loadingOverlay.style.display = 'flex'; 
        startTypewriterAnimation();
        updateProgress(0, 'Uploading file...');
        updateFileQueueItemStatusById(file.id, 'Processing');

        if (file.error) {
            delete file.error;
            updateFileQueue();
        }

        const isLocalModel = ['tiny', 'base', 'small', 'medium', 'large', 'large-v2', 'large-v3', 'turbo'].includes(selectedModel);
        
        if (isLocalModel && !serverAvailable) {
            handleApiError(file.id, 'Local models require the Python server to be running.');
            return;
        }


        if ((!serverAvailable && !isLocalModel) || selectedModel === 'gladia') {
            try {
                updateProgress(10, 'Connecting to cloud API...');
                const result = await transcribeWithCloudAPI(file, selectedModel);
                handleDirectAPIResult(file, selectedModel, result);
            } catch (error) {
                console.error('Direct API error:', error);
                handleApiError(file.id, error.message || 'Cloud API error');
            }
            return;
        }


        const formData = new FormData();
        formData.append('file', file);
        formData.append('job_id', currentJobId);
        formData.append('model_option', selectedModel);

        let endpoint = '/transcribe_local';
        let apiKey = '';

        switch(selectedModel) {
            case "whisper-1":
                endpoint = "/transcribe";
                apiKey = document.getElementById('api_key_cloud').value.trim(); // Trim whitespace
                if (!apiKey) { handleApiError(file.id, 'OpenAI API Key Missing'); return; }
                formData.append('api_key', apiKey); saveApiKeyIfChanged('openaiApiKey', apiKey);
                break;
            case "gpt-4o-transcribe":
            case "gpt-4o-mini-transcribe":
                endpoint = selectedModel === "gpt-4o-transcribe" ? 
                           "/transcribe_openai_gpt4o" : "/transcribe_openai_gpt4o_mini";
                apiKey = document.getElementById('api_key_cloud').value.trim(); // Trim whitespace
                if (!apiKey) { handleApiError(file.id, 'OpenAI API Key Missing'); return; }
                formData.append('api_key', apiKey); saveApiKeyIfChanged('openaiApiKey', apiKey);
                
                // Add prompt if provided
                const prompt = document.getElementById('gpt4o_prompt').value.trim();
                if (prompt) {
                    formData.append('prompt', prompt);
                    console.log(`Using prompt for ${selectedModel}: ${prompt.substring(0, 50)}...`);
                }
                break;
            case "nova-3":
                endpoint = "/transcribe_deepgram";
                apiKey = document.getElementById('deepgram_api_key').value.trim(); // Trim whitespace
                if (!apiKey) { handleApiError(file.id, 'Deepgram API Key Missing'); return; }
                formData.append('deepgram_api_key', apiKey); saveApiKeyIfChanged('deepgramApiKey', apiKey);
                formData.append('summarize_enabled', summarizeCheckbox.checked ? 'true' : 'false');
                formData.append('topics_enabled', topicsCheckbox.checked ? 'true' : 'false');
                break;
            case "gladia":
                endpoint = "/transcribe_gladia";
                apiKey = document.getElementById('gladia_api_key').value.trim(); // Trim whitespace
                if (!apiKey) { handleApiError(file.id, 'Gladia v2 API Key Missing'); return; }
                formData.append('gladia_api_key', apiKey); saveApiKeyIfChanged('gladiaApiKey', apiKey);
                break;
            case "scribe-v1":
                endpoint = "/transcribe_elevenlabs";
                apiKey = document.getElementById('elevenlabs_api_key').value.trim(); // Trim whitespace
                if (!apiKey) { handleApiError(file.id, 'ElevenLabs API Key Missing'); return; }
                formData.append('elevenlabs_api_key', apiKey); saveApiKeyIfChanged('elevenlabsApiKey', apiKey);
                break;
        }

        // Start Transcription

        fetch(endpoint, { method: 'POST', body: formData })
        .then(response => {
            if (!response.ok) { return response.json().then(err => { throw new Error(err.error || `Server error: ${response.status}`); }).catch(() => { throw new Error(`HTTP error! status: ${response.status}`); }); }
            return response.json();
        })
        .then(data => {
            console.log('Initial server response:', data);
            if (data.status !== 'started') throw new Error(data.error || 'Failed to start job.');
            updateProgress(10, 'Waiting for processing...'); // Wait for socket events
        })
        .catch(error => {
            console.error('Error sending file/starting job:', error);
            handleApiError(file.id, error.message || 'Could not start transcription.'); // Use helper for error
        });
    }

     function handleApiError(fileId, errorMessage){
          showToast('error', 'Error', errorMessage);
          updateFileQueueItemStatusById(fileId, 'Failed');
          const fileInQueue = fileQueue.find(f => f.id === fileId);
          if(fileInQueue) fileInQueue.error = true;
          generationInProgress = false;
          stopTypewriterAnimation();
          domCache.loadingOverlay.style.display = 'none';
          // Ensure progress bar is hidden if error occurs before completion
          domCache.progressContainer.classList.remove('active');
          processNextFileInQueue();
     }

    function cancelCurrentTranscription() {
      if (generationInProgress && activeProcessingQueue.length > 0 && currentProcessingIndex >= 0) {
          const jobIdToCancel = document.getElementById('job_id').value;
          const fileId = activeProcessingQueue[currentProcessingIndex]?.id;
          console.log(`User cancelling job: ${jobIdToCancel} for file: ${fileId}`);
          socket.emit('cancel_transcription', { job_id: jobIdToCancel });
          
          // Immediately clean up UI
          stopTypewriterAnimation();
          showStatsLoading(false);
          domCache.loadingOverlay.style.display = 'none';
          domCache.progressContainer.classList.remove('active');
          
          if (fileId) {
              updateFileQueueItemStatusById(fileId, 'Cancelled');
              const fileInQueue = fileQueue.find(f => f.id === fileId);
              if(fileInQueue) {
                  updateFileQueue();
              }
          }
          
          generationInProgress = false;
          isCancelled = true;
          
          updateTranscribeButtonText();
      } else { 
          console.log("Nothing to cancel."); 
          resetTranscriptionUI(); 
      }
    }

    // --- Media Preview & Sync ---
    function cleanupPreview() {
        // Revoke previous URL and destroy wavesurfer instances
        if (currentPreviewedFile?.objectURL) {
            URL.revokeObjectURL(currentPreviewedFile.objectURL);
             console.log("Revoked Object URL for:", currentPreviewedFile.id);
        }
        if (wavesurfer) {
            wavesurfer.destroy();
            wavesurfer = null;
            console.log("Destroyed audio wavesurfer");
        }
        if (videoWavesurfer) { // Destroy video's WS instance
             videoWavesurfer.destroy();
             videoWavesurfer = null;
             console.log("Destroyed video wavesurfer");
        }
        currentPreviewedFile = null; // Clear the tracking variable
        // Explicitly stop video player
        previewPlayer.pause();
        previewPlayer.removeAttribute('src');
        previewPlayer.load();
    }

    function showFilePreview(file) {
        if (!file || currentPreviewedFile?.id === file.id) {
            console.log("Preview requested for same file or no file, skipping reload.");
            return; // Avoid unnecessary reloads
        }
        console.log("Showing preview for:", file.name, file.id);


        cleanupPreview();

        // Setup new preview tracking
        currentPreviewedFile = { id: file.id, type: file.type, objectURL: null }; // Reset wavesurfer instance initially
        currentFileDuration = 0; // Reset duration
        requestPriceCalculatorUpdate(); // Reset price (debounced)

        // Hide players initially
        previewPlayer.style.display = 'none';
        audioPlayerContainer.style.display = 'none';
        showVideoBtn.style.display = 'none';
        showWaveformBtn.style.display = 'none';
        showVideoBtn.classList.remove('active'); // Deactivate buttons
        showWaveformBtn.classList.remove('active');
        playPauseButton.innerHTML = '<i class="ri-play-fill"></i>'; // Reset button

        try {
             currentPreviewedFile.objectURL = URL.createObjectURL(file);
             console.log("Created Object URL:", currentPreviewedFile.objectURL);
        } catch (e) {
             console.error("Error creating object URL:", e);
             handleApiError(file.id, "Cannot create preview URL.");
             currentPreviewedFile = null; // Clear tracking if URL fails
             return;
        }

        if (file.type.startsWith('video/')) {
            console.log("Setting up video preview...");
            showVideoBtn.style.display = 'inline-flex';
            showWaveformBtn.style.display = 'inline-flex';
            previewPlayer.style.display = 'block'; // Show video first by default
            showVideoBtn.classList.add('active'); // Activate video button

            previewPlayer.src = currentPreviewedFile.objectURL;
            previewPlayer.onloadedmetadata = () => {
                 currentFileDuration = previewPlayer.duration || 0;
                 console.log("Video duration:", currentFileDuration);
                 requestPriceCalculatorUpdate();
                 attachSyncToPlayer();
                 setupPlayerEventHandlers();
                 // Initialize WaveSurfer for video in the background
                 initializeVideoWaveform(currentPreviewedFile.objectURL);
            };
            previewPlayer.onerror = (e) => { console.error("Error loading video:", e); showToast('error', 'Video Error', 'Could not load video preview.'); currentFileDuration = 0; requestPriceCalculatorUpdate(); };

        } else if (file.type.startsWith('audio/')) {
            console.log("Setting up audio preview...");
            audioPlayerContainer.style.display = 'flex'; // Show audio container
            // Use the main 'wavesurfer' instance for direct audio
            const colors = getWaveformColors();
            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: colors.waveColor,
                progressColor: colors.progressColor,
                height: 60,
                responsive: true,
                backend: 'MediaElement',
                mediaControls: false,
                normalize: true,
                partialRender: true
            });
            wavesurfer.isReady = false;
            wavesurfer.load(currentPreviewedFile.objectURL);
            wavesurfer.on('ready', () => { wavesurfer.isReady = true; currentFileDuration = wavesurfer.getDuration() || 0; document.querySelector(".time-right").textContent = formatTimeForDisplay(currentFileDuration); document.querySelector(".time-left").textContent = "0:00"; attachSyncToPlayer(); requestPriceCalculatorUpdate(); setupPlayerEventHandlers(); }); // Added setupPlayerEventHandlers here too
            wavesurfer.on('error', (err) => { showToast('error', 'Audio Error', 'Failed to load audio waveform.'); currentFileDuration = 0; requestPriceCalculatorUpdate(); });
            setupAudioSeekPreview(); // Add seek preview for audio
        } else {
            showToast('warning', 'Unsupported File', 'Cannot preview this file type.');
            requestPriceCalculatorUpdate();
        }
    }

    function initializeVideoWaveform(url) {
         // Use the separate instance for video's waveform
        if (videoWavesurfer) videoWavesurfer.destroy();
        const colors = getWaveformColors();
        videoWavesurfer = WaveSurfer.create({
            container: '#waveform',
            waveColor: colors.waveColor,
            progressColor: colors.progressColor,
            height: 60,
            responsive: true,
            backend: 'MediaElement',
            mediaControls: false,
            normalize: true,
            partialRender: true
        });
        videoWavesurfer.isReady = false;
        videoWavesurfer.load(url); // Load the same video URL
        videoWavesurfer.on('ready', () => { videoWavesurfer.isReady = true; setupPlayerEventHandlers(); setupAudioSeekPreview(); }); // Attach handlers when ready
        videoWavesurfer.on('error', (err) => { showToast('error', 'Waveform Error', 'Could not load waveform from video.'); });
        if(currentPreviewedFile) currentPreviewedFile.wavesurferInstance = videoWavesurfer; // Store instance
    }

    function setupAudioSeekPreview() { // Separate function for audio seek preview logic
        const waveformEl = document.getElementById('waveform');
        let isWaveformDragging = false;
        waveformEl.removeEventListener('mousemove', handleWaveformMouseMove); waveformEl.removeEventListener('mouseleave', handleWaveformMouseLeave); waveformEl.removeEventListener('mousedown', handleWaveformMouseDown); document.removeEventListener('mouseup', handleWaveformMouseUp); // Use document for mouseup
        function handleWaveformMouseMove(e) {
            const currentWS = (currentPreviewedFile?.type.startsWith('video/')) ? videoWavesurfer : wavesurfer;
            if (!currentWS?.isReady) return;
            const rect = waveformEl.getBoundingClientRect(); const x = e.clientX - rect.left; const duration = currentWS.getDuration() || 0;
            const time = Math.max(0, Math.min(duration, (x / rect.width) * duration));
            document.querySelector(".time-center").textContent = formatTimeForDisplay(time);
            if (isWaveformDragging) currentWS.seekTo(time / duration);
        }
        function handleWaveformMouseLeave() { if (!isWaveformDragging) document.querySelector(".time-center").textContent = ""; }
        function handleWaveformMouseDown(e){
            const currentWS = (currentPreviewedFile?.type.startsWith('video/')) ? videoWavesurfer : wavesurfer;
            if (!currentWS?.isReady) return;
            isWaveformDragging = true; handleWaveformMouseMove(e); // Seek immediately
        }
        function handleWaveformMouseUp(){ if (isWaveformDragging) { isWaveformDragging = false; handleWaveformMouseLeave(); }}
        waveformEl.addEventListener('mousemove', handleWaveformMouseMove); waveformEl.addEventListener('mouseleave', handleWaveformMouseLeave); waveformEl.addEventListener('mousedown', handleWaveformMouseDown); document.addEventListener('mouseup', handleWaveformMouseUp);
    }

    function showVideoPreview() {
        if (!currentPreviewedFile || !currentPreviewedFile.type.startsWith('video/')) return;
        audioPlayerContainer.style.display = 'none';
        previewPlayer.style.display = 'block';
        showVideoBtn.classList.add('active');
        showWaveformBtn.classList.remove('active');
        if (videoWavesurfer?.isPlaying()) videoWavesurfer.pause();
        // Sync time
        if (videoWavesurfer?.isReady) {
            try{
                previewPlayer.currentTime = videoWavesurfer.getCurrentTime();
            } catch(e){ }
        }
    }

    function showWaveformPreview() {
        if (!currentPreviewedFile || !currentPreviewedFile.type.startsWith('video/')) return;
        if (!videoWavesurfer?.isReady) {
            showToast('info', 'Waveform Loading', 'Please wait for waveform to generate.');
            return;
        }
        previewPlayer.style.display = 'none';
        audioPlayerContainer.style.display = 'flex'; // Show the audio container
        showWaveformBtn.classList.add('active');
        showVideoBtn.classList.remove('active');
        if (!previewPlayer.paused) previewPlayer.pause();
        // Sync time
        if (!isNaN(previewPlayer.currentTime)) {
             const duration = videoWavesurfer.getDuration();
             if(duration > 0) videoWavesurfer.seekTo(previewPlayer.currentTime / duration);
        }
    }


    function setupPlayerEventHandlers() {
        // Video Player Events
        previewPlayer.removeEventListener('play', updatePlayButtonToPause); previewPlayer.removeEventListener('pause', updatePlayButtonToPlay); previewPlayer.removeEventListener('ended', updatePlayButtonToPlay);
        previewPlayer.addEventListener('play', updatePlayButtonToPause); previewPlayer.addEventListener('pause', updatePlayButtonToPlay); previewPlayer.addEventListener('ended', updatePlayButtonToPlay);

        // Assign correct WaveSurfer instance based on current preview type
        const currentWS = (currentPreviewedFile?.type.startsWith('video/')) ? videoWavesurfer : wavesurfer;

        if (currentWS) {
             currentWS.un('play'); currentWS.un('pause'); currentWS.un('finish');
             currentWS.on('play', updatePlayButtonToPause);
             currentWS.on('pause', updatePlayButtonToPlay);
             currentWS.on('finish', updatePlayButtonToPlay); // Reset on finish
        }
    }

    function updatePlayButtonToPause() { playPauseButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M13 15L8 18L8 6L13 9L13 15"><animate fill="freeze" attributeName="d" dur="0.1s" values="M13 15L8 18L8 6L13 9L13 15;M9 18L7 18L7 6L9 6L9 18"/></path><path d="M13 9L18 12L18 12L13 15L13 9"><animate fill="freeze" attributeName="d" dur="0.1s" values="M13 9L18 12L18 12L13 15L13 9;M15 6L17 6L17 18L15 18L15 6"/></path></g></svg>'; }
    function updatePlayButtonToPlay() { playPauseButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="currentColor" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M9 6L9 18L7 18L7 6z"><animate fill="freeze" attributeName="d" dur="0.1s" values="M9 18L7 18L7 6L9 6L9 18;M13 15L8 18L8 6L13 9L13 15"/><set attributeName="opacity" begin="0.4s" to="0"/></path><path d="M15 6L17 6L17 18L15 18L15 6"><animate fill="freeze" attributeName="d" dur="0.1s" values="M15 6L17 6L17 18L15 18L15 6;M13 9L18 12L18 12L13 15L13 9"/><set attributeName="opacity" begin="0.4s" to="0"/></path><path d="M8 6L18 12L8 18z" opacity="0"><set attributeName="opacity" begin="0.4s" to="1"/></path></g></svg>'; }

    function togglePlayPause() {
        try {
            const isVideoVisible = previewPlayer.style.display !== 'none';
            const isAudioVisible = audioPlayerContainer.style.display !== 'none';
            const currentWS = (currentPreviewedFile?.type.startsWith('video/')) ? videoWavesurfer : wavesurfer;

            if (isVideoVisible && currentPreviewedFile?.type.startsWith('video/') && previewPlayer.readyState >= 2) {
                if (previewPlayer.paused) {
                    // If waveform was playing, sync time before playing video
                    if (currentWS?.isPlaying()) {
                         previewPlayer.currentTime = currentWS.getCurrentTime();
                         currentWS.pause(); // Pause waveform
                    }
                    previewPlayer.play().catch(err => showToast('error', 'Playback Error', 'Video play error: ' + err.message));
                } else {
                    previewPlayer.pause();
                }
            } else if (isAudioVisible && currentWS?.isReady) {
                 if (currentWS.isPlaying()) {
                      currentWS.pause();
                 } else {
                      // If video was playing, sync time before playing waveform
                     if (!previewPlayer.paused) {
                           const duration = currentWS.getDuration();
                           if(duration > 0) currentWS.seekTo(previewPlayer.currentTime / duration);
                           previewPlayer.pause(); // Pause video
                     }
                     currentWS.play();
                 }
            } else {
                showToast('info', 'Player Not Ready', 'Media loading or no file selected.');
            }
        } catch (err) {
            console.error('Error in togglePlayPause:', err);
            showToast('error', 'Playback Error', 'Error: ' + err.message);
        }
    }

    function syncAudio(time) {
        if (isNaN(time)) return;
        const timeLeftEl = audioPlayerContainer.querySelector(".time-left"); // Target specific time display
        if(timeLeftEl) timeLeftEl.textContent = formatTimeForDisplay(time);
        // Throttle highlight updates to animation frames
        queuedHighlightTime = time;
        if (!highlightScheduled) {
            highlightScheduled = true;
            requestAnimationFrame(() => {
                highlightScheduled = false;
                if (queuedHighlightTime !== null) {
                    updateTranscriptHighlight(queuedHighlightTime);
                }
            });
        }
    }

    function updateTranscriptHighlight(currentTime) {
         if (isNaN(currentTime)) return;
         const activeTab = transcriptFormatSelect.value;
         if (!activeTab) return;
         const contentElement = document.getElementById(`${activeTab}Transcript`);
         if (!contentElement) return;

         const segments = contentElement.querySelectorAll(".transcript-segment");
         let highlightedSegment = null;

         segments.forEach(segment => {
             segment.classList.remove("highlighted", "next-segment");
             const start = parseFloat(segment.getAttribute("data-start"));
             const end = parseFloat(segment.getAttribute("data-end"));
             if (!isNaN(start) && !isNaN(end) && currentTime >= start && currentTime <= end) {
                 segment.classList.add("highlighted");
                 highlightedSegment = segment;
             }
         });

         if (highlightedSegment) {
             const containerRect = contentElement.getBoundingClientRect();
             const segmentRect = highlightedSegment.getBoundingClientRect();
             if (segmentRect.top < containerRect.top || segmentRect.bottom > containerRect.bottom) {
                 highlightedSegment.scrollIntoView({ behavior: 'smooth', block: 'center' });
             }
         } else {
             let closestSegment = null; let minStartTime = Infinity;
             segments.forEach(segment => {
                 const start = parseFloat(segment.getAttribute("data-start"));
                 if (!isNaN(start) && start > currentTime && start < minStartTime) { minStartTime = start; closestSegment = segment; }
             });
             if (closestSegment) closestSegment.classList.add("next-segment");
         }
     }

    function handleVideoTimeUpdate() {
        syncAudio(this.currentTime);
    }

    function attachSyncToPlayer() {
        previewPlayer.removeEventListener("timeupdate", handleVideoTimeUpdate);
        previewPlayer.addEventListener("timeupdate", handleVideoTimeUpdate);

        // Assign correct WaveSurfer instance based on current preview type
        const currentWS = (currentPreviewedFile?.type.startsWith('video/')) ? videoWavesurfer : wavesurfer;

        if (currentWS) {
            currentWS.un("audioprocess");
            currentWS.un("seek");
            if (currentWS.isReady) {
                currentWS.on("audioprocess", syncAudio);
                currentWS.on("seek", (p) => syncAudio(p * currentWS.getDuration()));
            } else {
                // This might be redundant if ready handler already does this, but safe
                currentWS.once("ready", () => {
                    currentWS.isReady = true;
                    currentWS.on("audioprocess", syncAudio);
                    currentWS.on("seek", (p) => syncAudio(p * currentWS.getDuration()));
                });
            }
        }
         setupPlayerEventHandlers(); // Re-attach play/pause handlers
    }

    function setupTranscriptClickDelegation() {
        document.querySelectorAll('.transcript-content .transcript-body').forEach(container => {
            container.removeEventListener('click', handleTranscriptClick);
            container.addEventListener('click', handleTranscriptClick);
        });
    }

    function handleTranscriptClick(event) {
        const seekButton = event.target.closest('.seek-btn');
        if (seekButton) {
            const segment = seekButton.closest('.transcript-segment');
            if (segment?.dataset.start) {
                const startTime = parseFloat(segment.dataset.start);
                if (!isNaN(startTime)) {
                    const isVideoVisible = previewPlayer.style.display !== 'none';
                    const currentWS = (currentPreviewedFile?.type.startsWith('video/')) ? videoWavesurfer : wavesurfer;

                    if (isVideoVisible && previewPlayer.duration > 0) {
                        const wasPaused = previewPlayer.paused;
                        previewPlayer.currentTime = startTime;
                        if (wasPaused) previewPlayer.play().catch(err => console.error('Error playing video after seek:', err));
                    } else if (currentWS?.isReady) {
                        const duration = currentWS.getDuration();
                        const wasPaused = !currentWS.isPlaying();
                        if (duration > 0) {
                            currentWS.seekTo(startTime / duration);
                            if (wasPaused) currentWS.play();
                        }
                    }
                }
            }
        }
    }

    // --- Transcript Display & Actions ---
     function showFileResult(fileId) {
        const results = getCurrentFileResult(fileId);
        if (!fileId || !results) return;
        clearTranscriptDisplay(); // Clear first
        // Set content for each tab
        document.querySelector('#defaultTranscript .transcript-body').innerHTML = results.default_transcript;
        document.querySelector('#numberedTranscript .transcript-body').innerHTML = results.numbered_transcript;
        document.querySelector('#srtTranscript .transcript-body').innerHTML = results.srt_text;
        document.querySelector('#vttTranscript .transcript-body').innerHTML = results.vtt_text;
        document.querySelector('#tsvTranscript .transcript-body').innerHTML = results.tsv_text;

        // Deepgram features: Set Summary and Topics if available
        const isDeepgram = results.model === 'nova-3';
        if (isDeepgram && results.summary_text) {
            summaryTranscriptDiv.querySelector('.transcript-body').innerText = results.summary_text;
        }
        if (isDeepgram && results.topics_data) {
            topicsTranscriptDiv.querySelector('.transcript-body').innerHTML = formatTopics(results.topics_data);
        }

        // Show/hide special tabs
        summaryOption.style.display = isDeepgram && results.summary_text ? 'block' : 'none';
        topicsOption.style.display = isDeepgram && results.topics_data ? 'block' : 'none';

        const currentTab = transcriptFormatSelect.value;
        if ((currentTab === 'summary' && summaryOption.style.display === 'none') || 
            (currentTab === 'topics' && topicsOption.style.display === 'none')) {
            switchTab('default'); // Switch if current tab became hidden
        }

        document.querySelector('.transcript-title-content').innerHTML = `<i class="ri-file-text-line"></i><h2>${results.fileName} <span style="opacity:0.6; font-weight:normal; font-size:0.9rem;">(${results.model.replace('_', '-')} - ${results.language})</span></h2>`; // Show detected lang & formatted model
        updateActionButtons(); // Enable copy/download
        domCache.loadingOverlay.style.display = 'none'; stopTypewriterAnimation();
        updateTranscriptionStats(results.default_transcript, results.elapsed_time); // Pass elapsed time
        setTimeout(() => { attachSyncToPlayer(); setupTranscriptClickDelegation(); }, 100);
    }
    function clearTranscriptDisplay() {
        document.querySelectorAll('.transcript-content .transcript-body').forEach(el => el.innerHTML = '');
        summaryOption.style.display = 'none';
        topicsOption.style.display = 'none';
        document.querySelector('.transcript-title-content').innerHTML = `<i class="ri-file-text-line"></i><h2>Transcript</h2>`;
        updateActionButtons();
    }
    function switchTab(tabType) {
        document.querySelectorAll('.transcript-content').forEach(c => c.style.display = 'none');
        transcriptFormatSelect.value = tabType;
        const content = document.getElementById(`${tabType}Transcript`);
        if(content) content.style.display = 'block';

        // Populate Summary/Topics only if the tab is selected and data exists
        if (currentActiveFile) {
           const results = getCurrentFileResult(currentActiveFile); // Get current view result
           if (!results) return;
           if (tabType === 'summary') {
               summaryTranscriptDiv.querySelector('.transcript-body').innerText = results.summary_text || 'Summary not available.';
           } else if (tabType === 'topics') {
               topicsTranscriptDiv.querySelector('.transcript-body').innerHTML = results.topics_data ? formatTopics(results.topics_data) : 'Topics not available.';
           }
        } else if (tabType === 'summary' || tabType === 'topics') {
           // Handle case where no file/results exist when switching to these tabs
           document.getElementById(`${tabType}Transcript`).querySelector('.transcript-body').innerHTML = '<p><i>No data available.</i></p>';
        }
        updateActionButtons(); // Update copy/download button state
    }
    function updateActionButtons(){
        const hasContent = !!(currentActiveFile && getCurrentFileResult(currentActiveFile));
        const hasActiveFile = !!currentActiveFile;
        if (!isEditMode) {
        copyButton.disabled = !hasContent;
        downloadButton.disabled = !hasContent;
            editButton.disabled = !hasContent;
            uploadButton.disabled = false;
            
            const downloadDropdown = document.getElementById('downloadDropdown');
            if (downloadDropdown) {
                if (!hasContent) {
                    downloadDropdown.classList.add('disabled');
                } else {
                    downloadDropdown.classList.remove('disabled');
                }
            }
        }
    }
    function increaseFontSize() {
        currentFontSize = Math.min(32, currentFontSize + 2);
        document.querySelectorAll('.transcript-content .transcript-body').forEach(el => {
            if(el) el.style.fontSize = currentFontSize + "px";
        });
    }
    function decreaseFontSize() {
        currentFontSize = Math.max(10, currentFontSize - 2);
        document.querySelectorAll('.transcript-content .transcript-body').forEach(el => {
             if(el) el.style.fontSize = currentFontSize + "px";
        });
    }
    
    function copyTranscript() {
        const results = getCurrentFileResult(currentActiveFile);
        if (!currentActiveFile || !results) {
            showToast('warning', 'No Transcript', 'No transcript to copy.');
            return;
        }
        
        const activeTab = transcriptFormatSelect.value;
        if (!activeTab) {
            showToast('warning', 'No Tab Selected', 'No transcript tab selected.');
            return;
        }
        
        let textToCopy = '';
        const activeContentDiv = document.getElementById(`${activeTab}Transcript`);

        // Try to get plain text versions first for SRT/VTT/TSV
        if (activeTab === 'srt' && results.plain_srt) {
            textToCopy = results.plain_srt;
        } else if (activeTab === 'vtt' && results.plain_vtt) {
            textToCopy = results.plain_vtt;
        } else if (activeTab === 'tsv' && results.tsv_plain) {
            textToCopy = results.tsv_plain;
        } else if (activeTab === 'summary' && results.summary_text) {
            textToCopy = results.summary_text;
        } else if (activeTab === 'topics' && results.topics_plain) {
            textToCopy = results.topics_plain;
        } else if (activeContentDiv) {
            // Fallback to extracting text from the HTML
            const transcriptBody = activeContentDiv.querySelector('.transcript-body');
            if (transcriptBody) {
                textToCopy = transcriptBody.innerText || transcriptBody.textContent || '';
            }
        }

        if (textToCopy && textToCopy.trim()) {
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                    showToast('success', 'Copied', 'Content copied to clipboard.');
                    copyButton.innerHTML = '<i class="ri-check-line"></i><span>Copied!</span>';
                    setTimeout(() => { copyButton.innerHTML = '<i class="ri-clipboard-line"></i><span>Copy</span>'; }, 2000);
                })
                .catch(err => { 
                    console.error('Copy failed:', err); 
                    showToast('error', 'Copy Failed', 'Could not copy to clipboard.'); 
                });
        } else {
            showToast('warning', 'Nothing to Copy', 'No content available to copy.');
        }
    }
    function downloadTranscriptFormat(format) {
        const results = getCurrentFileResult(currentActiveFile);
        if (!currentActiveFile || !results) { showToast('error', 'No Transcript', 'Nothing to download.'); return; }
        if (!format) return;
        const baseFileName = results.fileName.replace(/\.[^/.]+$/, '');
        const modelName = results.model || 'unknown';
        let contentToDownload = '';
        let fileExtension = 'txt';

        switch (format) {
            case 'srt':
                contentToDownload = results.plain_srt || htmlToPlainTextSrt(document.querySelector("#srtTranscript .transcript-body")?.innerHTML || '');
                fileExtension = 'srt';
                break;
            case 'vtt':
                contentToDownload = results.plain_vtt || htmlToPlainTextVtt(document.querySelector("#vttTranscript .transcript-body")?.innerHTML || '');
                fileExtension = 'vtt';
                break;
            case 'tsv':
                contentToDownload = results.tsv_plain || htmlToPlainTextTsv(document.querySelector("#tsvTranscript .transcript-body")?.innerHTML || '');
                fileExtension = 'tsv';
                break;
            case 'summary':
               contentToDownload = document.querySelector("#summaryTranscript .transcript-body")?.innerText || '';
               fileExtension = 'txt';
               break;
           case 'topics':
               contentToDownload = document.querySelector("#topicsTranscript .transcript-body")?.innerText || '';
                fileExtension = 'txt';
               break;
          case 'default':
          case 'numbered':
          default: // Fallback for default/numbered or unknown
              contentToDownload = document.querySelector(`#${format}Transcript .transcript-body`)?.innerText || '';
              fileExtension = 'txt';
              break;
        }

        if (!contentToDownload) {
           showToast('warning', 'Nothing to Download', 'No content found for the current tab.');
           return;
        }

        const blob = new Blob([contentToDownload], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        // Include model and tab type in filename
        a.download = `${baseFileName}_${modelName.replace('_','-')}_${format}.${fileExtension}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showToast('success', 'Downloaded', `Downloaded ${a.download}`);
    }

    // Backwards compatibility function for the current selected format
    function downloadTranscript() {
        const activeTab = transcriptFormatSelect.value;
        downloadTranscriptFormat(activeTab);
    }

    function downloadTranscript_old() {
        const results = getCurrentFileResult(currentActiveFile);
        if (!currentActiveFile || !results) { 
            showToast('error', 'No Transcript', 'Nothing to download.'); 
            return; 
        }
        
        const activeTab = transcriptFormatSelect.value;
        if (!activeTab) {
            showToast('warning', 'No Tab Selected', 'No transcript tab selected.');
            return;
        }
        const baseFileName = results.fileName.replace(/\.[^/.]+$/, '');
        const modelName = results.model || 'unknown';
        let contentToDownload = '';
        let fileExtension = 'txt';

        switch (activeTab) {
            case 'srt':
                contentToDownload = results.plain_srt || htmlToPlainTextSrt(document.querySelector("#srtTranscript .transcript-body")?.innerHTML || '');
                fileExtension = 'srt';
                break;
            case 'vtt':
                contentToDownload = results.plain_vtt || htmlToPlainTextVtt(document.querySelector("#vttTranscript .transcript-body")?.innerHTML || '');
                fileExtension = 'vtt';
                break;
            case 'tsv':
                contentToDownload = results.tsv_plain || htmlToPlainTextTsv(document.querySelector("#tsvTranscript .transcript-body")?.innerHTML || '');
                fileExtension = 'tsv';
                break;
            case 'summary':
                contentToDownload = results.summary_text || document.querySelector("#summaryTranscript .transcript-body")?.innerText || '';
                fileExtension = 'txt';
                break;
            case 'topics':
                contentToDownload = results.topics_plain || document.querySelector("#topicsTranscript .transcript-body")?.innerText || '';
                fileExtension = 'txt';
                break;
            case 'default':
            case 'numbered':
            default:
                const activeContentDiv = document.querySelector(`#${activeTab}Transcript .transcript-body`);
                contentToDownload = activeContentDiv?.innerText || activeContentDiv?.textContent || '';
                fileExtension = 'txt';
                break;
        }

        if (!contentToDownload || !contentToDownload.trim()) {
           showToast('warning', 'Nothing to Download', 'No content available to download.');
           return;
        }

        const blob = new Blob([contentToDownload], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${baseFileName}_${modelName.replace('_','-')}_${activeTab}.${fileExtension}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showToast('success', 'Downloaded', `Downloaded ${a.download}`);
    }
    // Helper needed for SRT/TSV download fallback
    function htmlToPlainTextSrt(srtHtml) { if (!srtHtml) return ''; const tempDiv = document.createElement('div'); tempDiv.innerHTML = srtHtml; let output = ""; tempDiv.querySelectorAll('.transcript-segment').forEach(seg => { const index = seg.querySelector('.srt-index')?.innerText.trim(); const timing = seg.querySelector('.srt-timing')?.innerText.trim(); const text = seg.querySelector('.srt-text')?.innerText.trim(); if (index && timing && text) output += `${index}\n${timing}\n${text}\n\n`; }); return output.trim(); }
    function htmlToPlainTextTsv(tsvHtml) { if (!tsvHtml) return ''; const tempDiv = document.createElement('div'); tempDiv.innerHTML = tsvHtml; let output = "Segment\tStart\tEnd\tText\n"; tempDiv.querySelectorAll('tbody tr.transcript-segment').forEach(row => { const cells = row.querySelectorAll('td'); if (cells.length === 4) { output += `${cells[0].innerText.trim()}\t${cells[1].innerText.trim()}\t${cells[2].innerText.trim()}\t${cells[3].innerText.trim()}\n`; } }); return output.trim(); }
    function htmlToPlainTextVtt(vttHtml) { if (!vttHtml) return ''; const tempDiv = document.createElement('div'); tempDiv.innerHTML = vttHtml; let output = ''; const header = tempDiv.querySelector('.vtt-header'); output += (header ? header.innerText.trim() : 'WEBVTT') + '\n\n'; tempDiv.querySelectorAll('.vtt-entry').forEach(entry => { const timing = entry.querySelector('.vtt-timing')?.innerText.trim(); const text = entry.querySelector('.vtt-text')?.innerText.trim(); if (timing && text) output += `${timing}\n${text}\n\n`; }); return output.trim(); }

    // --- Edit Mode Functions ---
    function toggleEditMode() {
        const activeTab = transcriptFormatSelect.value;
        const contentElement = document.getElementById(`${activeTab}Transcript`);
        const transcriptBody = contentElement.querySelector('.transcript-body');
        
        if (!isEditMode) {
            // Enter edit mode
            const currentText = getPlainTextFromTranscript(transcriptBody);
            originalEditContent = currentText;
            currentEditor = document.createElement('textarea');
            currentEditor.className = 'transcript-editor';
            currentEditor.value = currentText;
            currentEditor.style.fontSize = currentFontSize + 'px';
            
            transcriptBody.style.display = 'none';
            contentElement.insertBefore(currentEditor, transcriptBody);
            
            editButton.innerHTML = '<i class="ri-save-line"></i><span>Save</span>';
            editButton.classList.remove('btn-secondary');
            editButton.classList.add('btn-primary');
            isEditMode = true;
            
            cancelEditButton.style.display = 'inline-flex';
            findReplaceButton.style.display = 'inline-flex';
            copyButton.disabled = true;
            downloadButton.disabled = true;
            transcriptFormatSelect.disabled = true;
        } else {
            const editedText = currentEditor.value;
            saveEditedTranscript(editedText);
            
            currentEditor.remove();
            transcriptBody.style.display = 'block';
            currentEditor = null;
            
            editButton.innerHTML = '<i class="ri-edit-line"></i><span>Edit</span>';
            editButton.classList.remove('btn-primary');
            editButton.classList.add('btn-secondary');
            isEditMode = false;
            
            cancelEditButton.style.display = 'none';
            findReplaceButton.style.display = 'none';
            updateActionButtons();
            transcriptFormatSelect.disabled = false;
            originalEditContent = null;
            if (findReplacePanel.classList.contains('active')) {
                toggleFindReplace();
            }
        }
    }

    function cancelEditMode() {
        if (!isEditMode || !originalEditContent) return;
        
        const activeTab = transcriptFormatSelect.value;
        const contentElement = document.getElementById(`${activeTab}Transcript`);
        const transcriptBody = contentElement.querySelector('.transcript-body');
        
        currentEditor.value = originalEditContent;
        
        currentEditor.remove();
        transcriptBody.style.display = 'block';
        currentEditor = null;
        
        editButton.innerHTML = '<i class="ri-edit-line"></i><span>Edit</span>';
        editButton.classList.remove('btn-primary');
        editButton.classList.add('btn-secondary');
        isEditMode = false;
        
        cancelEditButton.style.display = 'none';
        findReplaceButton.style.display = 'none';
        updateActionButtons();
        transcriptFormatSelect.disabled = false;
        originalEditContent = null;
        if (findReplacePanel.classList.contains('active')) {
            toggleFindReplace();
        }
        
        showToast('info', 'Cancelled', 'Edit cancelled. No changes were saved.');
    }

    function getPlainTextFromTranscript(transcriptBody) {
        const segments = transcriptBody.querySelectorAll('.transcript-segment');
        if (segments.length > 0) {
            return Array.from(segments).map((segment) => {
                let output = '';
                const srtIndex = segment.querySelector('.srt-index');
                const srtTiming = segment.querySelector('.srt-timing');
                const srtText = segment.querySelector('.srt-text');
                const vttTiming = segment.querySelector('.vtt-timing');
                const vttText = segment.querySelector('.vtt-text');
                const segmentNumber = segment.querySelector('.segment-number');
                const segmentText = segment.querySelector('.segment-text');
                const tsvCells = segment.querySelectorAll('td');
                
                if (srtIndex && srtTiming && srtText) {
                    output += `${srtIndex.textContent.trim()}\n${srtTiming.textContent.trim()}\n`;
                    output += srtText.innerHTML.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '').trim();
                } else if (vttTiming && vttText) {
                    output += `${vttTiming.textContent.trim()}\n`;
                    output += vttText.innerHTML.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '').trim();
                } else if (segmentNumber && segmentText) {
                    output += `${segmentNumber.textContent.trim()}. `;
                    output += segmentText.innerHTML.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '').trim();
                } else if (tsvCells.length >= 4) {
                    output += Array.from(tsvCells).map(cell => cell.textContent.trim()).join('\t');
                } else {
                    output += segment.innerHTML.replace(/<button[^>]*>.*?<\/button>/gi, '').replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '').trim();
                }
                return output;
            }).join('\n\n');
        }
        return transcriptBody.textContent || transcriptBody.innerText || '';
    }

    function saveEditedTranscript(editedText) {
        const results = getCurrentFileResult(currentActiveFile);
        if (!currentActiveFile || !results) return;
        
        const activeTab = transcriptFormatSelect.value;
        
        // Handle special formats that don't sync with others
        if (activeTab === 'summary' || activeTab === 'topics') {
            if (activeTab === 'summary') results.summary_text = editedText;
            if (activeTab === 'topics') results.topics_plain = editedText;
        } else {
            // For transcript formats, regenerate all formats from edited content
            const segments = parseEditedTextToSegments(editedText, activeTab);
            const regeneratedFormats = buildAllTranscriptFormats(segments);
            
            // Update all transcript formats to keep them in sync
            Object.assign(results, regeneratedFormats);
        }
        
        const currentModel = getSelectedModel();
        if (currentActiveFile && currentModel) {
            setFileTranscription(currentActiveFile, currentModel, results);
        }
        
        showFileResult(currentActiveFile);
        showToast('success', 'Saved', 'Transcript changes saved and synced across all formats.');
    }

    function parseEditedTextToSegments(editedText, format) {
        // Get original segments with timing from stored results
        const results = getCurrentFileResult(currentActiveFile);
        const originalSegments = getOriginalSegmentsFromResults(results);
        
        // Extract just the text lines from edited content
        const editedLines = editedText.split('\n').filter(line => {
            const cleaned = line.trim();
            // Skip timing lines, index numbers, and empty lines
            return cleaned && 
                   !cleaned.match(/^\d+$/) && // Skip SRT indices
                   !cleaned.match(/\d{2}:\d{2}:\d{2}[,.]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[,.]\d{3}/) && // Skip timing
                   !cleaned.match(/^\d+\.\s/) && // Skip numbered prefixes
                   !cleaned.match(/^\d+\.\d+\t\d+\.\d+\t/); // Skip TSV timing
        });
        
        // Map edited text back to original segments with preserved timing
        const updatedSegments = [];
        for (let i = 0; i < Math.max(originalSegments.length, editedLines.length); i++) {
            const originalSeg = originalSegments[i];
            const editedText = editedLines[i] || '';
            
            updatedSegments.push({
                start: originalSeg ? originalSeg.start : i * 4,
                end: originalSeg ? originalSeg.end : (i + 1) * 4,
                text: editedText.trim()
            });
        }
        
        return updatedSegments.filter(seg => seg.text); // Remove empty segments
    }
    
    function getOriginalSegmentsFromResults(results) {
        // Try to extract segments from the default transcript HTML
        const defaultHtml = results.default_transcript || '';
        const segmentMatches = defaultHtml.match(/<div class="transcript-segment"[^>]*data-start="([^"]*)"[^>]*data-end="([^"]*)"[^>]*>(.*?)<\/div>/g);
        
        if (segmentMatches) {
            return segmentMatches.map(match => {
                const startMatch = match.match(/data-start="([^"]*)"/);
                const endMatch = match.match(/data-end="([^"]*)"/);
                const textMatch = match.match(/>(.*?)<\/div>$/);
                
                return {
                    start: parseFloat(startMatch ? startMatch[1] : 0),
                    end: parseFloat(endMatch ? endMatch[1] : 0),
                    text: textMatch ? textMatch[1].replace(/<[^>]*>/g, '').trim() : ''
                };
            });
        }
        
        // Fallback: create basic segments
        return [{start: 0, end: 1, text: ''}];
    }

    function convertPlainTextToTranscriptFormat(plainText, format) {
        const paragraphs = plainText.split(/\n\s*\n/).filter(p => p.trim());
        let output = "";
        
        switch (format) {
            case 'default':
                paragraphs.forEach(paragraph => {
                    const cleanText = paragraph.trim();
                    if (cleanText) {
                        const formattedText = cleanText.replace(/\n/g, '<br>');
                        output += `<div class="transcript-segment" data-start="0" data-end="0">`;
                        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
                        output += formattedText + '<br>';
                        output += "</div>\n";
                    }
                });
                break;
            case 'numbered':
                paragraphs.forEach((paragraph, i) => {
                    const cleanText = paragraph.trim();
                    if (cleanText) {
                        let number = i + 1;
                        let text = cleanText;
                        const numberMatch = cleanText.match(/^(\d+)\.?\s*(.*)/s);
                        if (numberMatch) {
                            number = parseInt(numberMatch[1]);
                            text = numberMatch[2];
                        }
                        const formattedText = text.replace(/\n/g, '<br>');
                        output += `<div class="transcript-segment" data-start="0" data-end="0">`;
                        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
                        output += `<div class="segment-number" style="opacity: 0.5;">${number}</div>`;
                        output += `<div class="segment-text">${formattedText}<br></div>`;
                        output += "</div>\n";
                    }
                });
                break;
                
            case 'srt':
                paragraphs.forEach((paragraph, i) => {
                    const lines = paragraph.trim().split('\n');
                    if (lines.length >= 3) {
                        // Parse SRT format: index, timing, text
                        const index = lines[0].trim();
                        const timing = lines[1].trim();
                        const text = lines.slice(2).join('\n');
                        const formattedText = text.replace(/\n/g, '<br>');
                        
                        output += `<div class="transcript-segment" data-start="0" data-end="0">`;
                        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
                        output += `<div class="srt-index srt-opacity" style="opacity: 0.5;">${index}</div>`;
                        output += `<div class="srt-timing srt-opacity" style="opacity: 0.5;">${timing}</div>`;
                        output += `<div class="srt-text">${formattedText}</div>`;
                        output += "</div>\n";
                    } else if (lines.length > 0) {
                        // Fallback: treat as simple text with auto-generated index and timing
                        const cleanText = paragraph.trim();
                        const formattedText = cleanText.replace(/\n/g, '<br>');
                        output += `<div class="transcript-segment" data-start="0" data-end="0">`;
                        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
                        output += `<div class="srt-index srt-opacity" style="opacity: 0.5;">${i + 1}</div>`;
                        output += `<div class="srt-timing srt-opacity" style="opacity: 0.5;">00:00:00,000 --> 00:00:00,000</div>`;
                        output += `<div class="srt-text">${formattedText}</div>`;
                        output += "</div>\n";
                    }
                });
                break;
                
            case 'vtt':
                paragraphs.forEach(paragraph => {
                    const lines = paragraph.trim().split('\n');
                    if (lines.length >= 2) {
                        // Parse VTT format: timing, text
                        const timing = lines[0].trim();
                        const text = lines.slice(1).join('\n');
                        const formattedText = text.replace(/\n/g, '<br>');
                        
                        output += `<div class="transcript-segment vtt-entry" data-start="0" data-end="0">`;
                        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
                        output += `<div class="vtt-timing vtt-opacity" style="opacity: 0.5;">${timing}</div>`;
                        output += `<div class="vtt-text">${formattedText}</div>`;
                        output += '</div>\n';
                    } else if (lines.length > 0) {
                        // Fallback: treat as simple text with default timing
                        const cleanText = paragraph.trim();
                        const formattedText = cleanText.replace(/\n/g, '<br>');
                        output += `<div class="transcript-segment vtt-entry" data-start="0" data-end="0">`;
                        output += `<button class="seek-btn btn btn-ghost btn-icon btn-sm" title="Seek to here"><i class="ri-play-circle-line"></i></button>`;
                        output += `<div class="vtt-timing vtt-opacity" style="opacity: 0.5;">00:00:00.000 --> 00:00:00.000</div>`;
                        output += `<div class="vtt-text">${formattedText}</div>`;
                        output += '</div>\n';
                    }
                });
                break;
                
            case 'tsv':
                output = '<table class="tsv-table"><thead><tr><th style="opacity: 0.5;">Segment</th><th style="opacity: 0.5;">Start</th><th style="opacity: 0.5;">End</th><th>Text</th></tr></thead><tbody>';
                paragraphs.forEach((paragraph, i) => {
                    const cleanText = paragraph.trim();
                    if (cleanText) {
                        output += `<tr class="transcript-segment" data-start="0" data-end="0">`;
                        output += `<td style="opacity: 0.5;">${i + 1}</td><td style="opacity: 0.5;">00:00:00,000</td><td style="opacity: 0.5;">00:00:00,000</td>`;
                        output += `<td>${cleanText}</td></tr>`;
                    }
                });
                output += '</tbody></table>';
                break;
                
            default:
                return plainText; // Return as-is for summary/topics
        }
        return output.trim();
    }

    function toggleFindReplace() {
        const isActive = findReplacePanel.classList.contains('active');
        if (isActive) {
            findReplacePanel.classList.remove('active');
            findReplaceButton.innerHTML = '<i class="ri-search-2-line"></i><span>Find & Replace</span><i class="ri-arrow-down-s-line"></i>';
            findReplaceButton.classList.remove('btn-primary');
            findReplaceButton.classList.add('btn-secondary');
            if (currentEditor) currentEditor.focus();
        } else {
            findReplacePanel.classList.add('active');
            findReplaceButton.innerHTML = '<i class="ri-search-2-line"></i><span>Find & Replace</span><i class="ri-arrow-up-s-line"></i>';
            findReplaceButton.classList.remove('btn-secondary');
            findReplaceButton.classList.add('btn-primary');
            findInput.focus();
        }
    }

    function findNext() {
        if (!currentEditor || !findInput.value) return;
        const searchText = findInput.value;
        const editorText = currentEditor.value;
        const currentPos = currentEditor.selectionStart;
        const foundIndex = editorText.indexOf(searchText, currentPos);
        if (foundIndex !== -1) {
            currentEditor.setSelectionRange(foundIndex, foundIndex + searchText.length);
            currentEditor.focus();
        } else {
            const foundFromStart = editorText.indexOf(searchText, 0);
            if (foundFromStart !== -1) {
                currentEditor.setSelectionRange(foundFromStart, foundFromStart + searchText.length);
                currentEditor.focus();
            } else {
                showToast('info', 'Not Found', `"${searchText}" not found.`);
            }
        }
    }

    function findPrevious() {
        if (!currentEditor || !findInput.value) return;
        const searchText = findInput.value;
        const editorText = currentEditor.value;
        const currentPos = currentEditor.selectionStart;
        const foundIndex = editorText.lastIndexOf(searchText, currentPos - 1);
        if (foundIndex !== -1) {
            currentEditor.setSelectionRange(foundIndex, foundIndex + searchText.length);
            currentEditor.focus();
        } else {
            const foundFromEnd = editorText.lastIndexOf(searchText);
            if (foundFromEnd !== -1) {
                currentEditor.setSelectionRange(foundFromEnd, foundFromEnd + searchText.length);
                currentEditor.focus();
            } else {
                showToast('info', 'Not Found', `"${searchText}" not found.`);
            }
        }
    }

    function replaceOne() {
        if (!currentEditor || !findInput.value) return;
        const searchText = findInput.value;
        const replaceText = replaceInput.value;
        const selectedText = currentEditor.value.substring(currentEditor.selectionStart, currentEditor.selectionEnd);
        if (selectedText === searchText) {
            const startPos = currentEditor.selectionStart;
            const beforeText = currentEditor.value.substring(0, startPos);
            const afterText = currentEditor.value.substring(currentEditor.selectionEnd);
            currentEditor.value = beforeText + replaceText + afterText;
            currentEditor.setSelectionRange(startPos + replaceText.length, startPos + replaceText.length);
            findNext();
        } else {
            findNext();
        }
    }

    function replaceAll() {
        if (!currentEditor || !findInput.value) return;
        const searchText = findInput.value;
        const replaceText = replaceInput.value;
        const originalText = currentEditor.value;
        
        // Count occurrences first
        const occurrences = originalText.split(searchText).length - 1;
        
        if (occurrences > 0) {
            const newText = originalText.split(searchText).join(replaceText);
            currentEditor.value = newText;
            showToast('success', 'Replaced', `Replaced ${occurrences} occurrence(s).`);
        } else {
            showToast('info', 'Not Found', `"${searchText}" not found.`);
        }
    }

    // --- Statistics ---
     function countParagraphs(htmlContent) { if (!htmlContent) return 0; const segmentMatch = htmlContent.match(/class="transcript-segment"/g); return segmentMatch ? segmentMatch.length : (htmlContent.trim() ? 1 : 0); }
     function htmlToPlainTextForStats(htmlContent) { if (!htmlContent) return ""; const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlContent; let text = ""; tempDiv.querySelectorAll('.segment-text, .srt-text, .vtt-text, td:last-child').forEach(el => { text += el.textContent + "\n"; }); if (!text.trim()) text = tempDiv.textContent || tempDiv.innerText || ""; return text.replace(/\s+/g, ' ').trim(); }
     function updateTranscriptionStats(transcriptHtml, elapsedTime = null) {
         if (!transcriptHtml) { resetTranscriptionStats(); return; }
         showStatsLoading(true);
         setTimeout(() => {
             const plainText = htmlToPlainTextForStats(transcriptHtml);
             const wordCount = countWords(plainText);
             const charCount = plainText.length;
             const paraCount = countParagraphs(transcriptHtml);

             const statItems = statsContainer.querySelectorAll('.stat-item');
             statItems[0].querySelector('.stat-value').textContent = wordCount.toLocaleString();
             statItems[1].querySelector('.stat-value').textContent = charCount.toLocaleString();
             statItems[2].querySelector('.stat-value').textContent = paraCount.toLocaleString();

             // Update Elapsed Time
             if(elapsedTime !== null && elapsedTime >= 0){
                  elapsedTimeValueEl.textContent = formatElapsedTime(elapsedTime); // Use helper function
             } else {
                  elapsedTimeValueEl.textContent = 'N/A';
             }

             showStatsLoading(false);
             statsContainer.style.display = 'flex';
         }, 50);
     }
     function resetTranscriptionStats() {
         const statItems = statsContainer.querySelectorAll('.stat-item');
         statItems.forEach((item, i) => {
             const valueEl = item.querySelector('.stat-value');
             if (valueEl) {
                 valueEl.textContent = (valueEl.id === 'elapsedTimeValue') ? '0s' : '0'; // Reset elapsed time to 0s
             }
         });
     }
     function formatElapsedTime(seconds) {
         if (seconds === null || seconds < 0) return 'N/A';
         const minutes = Math.floor(seconds / 60);
         const remainingSeconds = seconds % 60;
         if (minutes > 0) {
             return `${minutes}m ${remainingSeconds}s`;
         } else {
             return `${remainingSeconds}s`;
         }
     }
     function showStatsLoading(show) { statsContainer.style.display = show ? 'none' : 'flex'; statsLoading.style.display = show ? 'flex' : 'none'; }
     function countWords(text) { return text ? text.split(/\s+/).filter(Boolean).length : 0; }

    // --- Matrix raindrop animation when processing transcript ---
    function startTypewriterAnimation() {
        stopTypewriterAnimation();
        const container = domCache.typewriterContainer;
        if (!container) return;
        container.innerHTML = '';
        const letterCount = 150;

        function createRandomLetter() {
            if (!container || container.childNodes.length >= letterCount) return;

            const letter = document.createElement('div');
            letter.className = 'typewriter-letter';

            // Random position throughout the container
            const x = Math.floor(Math.random() * container.offsetWidth);
            const y = Math.floor(Math.random() * container.offsetHeight);
            letter.style.left = `${x}px`;
            letter.style.top = `${y}px`;

            // Weighted language selection
            let selectedLanguage;
            const languageKeys = Object.keys(languages);
            const useLatin = Math.random() < 0.7; // Higher chance for Latin letters to show

            if (useLatin) {
                selectedLanguage = languages.latin;
            } else {
                // For non-Latin, pick randomly from other languages
                const nonLatinKeys = languageKeys.filter(key => key !== 'latin');
                selectedLanguage = languages[nonLatinKeys[Math.floor(Math.random() * nonLatinKeys.length)]];
            }

            letter.textContent = selectedLanguage[Math.floor(Math.random() * selectedLanguage.length)];

            // Random size between 16px and 24px
            const size = Math.floor(16 + Math.random() * 8);
            letter.style.fontSize = `${size}px`;

            container.appendChild(letter);

            // Remove after animation completes
            setTimeout(() => {
                if (letter.parentNode === container) container.removeChild(letter);
            }, 4000);
        }

        // Create characters at a slower pace
        typewriterInterval = setInterval(() => {
            for (let i = 0; i < 3; i++) createRandomLetter();
        }, 400);
    }
    function stopTypewriterAnimation() { if (typewriterInterval) { clearInterval(typewriterInterval); typewriterInterval = null; const container = domCache.typewriterContainer; if (container) container.innerHTML = ''; } }
    function initializeTheme() { const savedTheme = localStorage.getItem('theme') || 'light'; applyTheme(savedTheme); }
    // function switchTheme(themeName) { applyTheme(themeName); localStorage.setItem('theme', themeName); showToast('info', 'Theme Changed', `Switched to ${themeName.charAt(0).toUpperCase() + themeName.slice(1)} theme`); } // Replaced by below
    // function toggleApiKeyVisibility() { const input = document.getElementById('api_key_cloud'), btn = document.getElementById('showApiKey'); if (input.type === 'password') { input.type = 'text'; btn.innerHTML = '<i class="ri-eye-off-line"></i>'; } else { input.type = 'password'; btn.innerHTML = '<i class="ri-eye-line"></i>'; } }
    function togglePasswordVisibility(inputId, button) { const input = document.getElementById(inputId); if (input.type === "password") { input.type = "text"; button.innerHTML = '<i class="ri-eye-off-line"></i>'; } else { input.type = "password"; button.innerHTML = '<i class="ri-eye-line"></i>'; } }
    function showToast(type, title, message) { 
        // Disable toasts on mobile view
        const isMobile = window.innerWidth <= 1200;
        if (isMobile) return;
        
        const tc = document.querySelector('.toast-container'), t = document.createElement('div'); 
        t.className = `toast toast-${type}`; 
        t.innerHTML = `<div class="toast-icon"><i class="ri-${type === 'success' ? 'check-line' : type === 'error' ? 'error-warning-line' : type === 'warning' ? 'alert-line' : 'information-line'}"></i></div><div class="toast-content"><div class="toast-title">${title}</div><div class="toast-message">${message}</div></div><button class="toast-close"><i class="ri-close-line"></i></button>`; 
        tc.appendChild(t); 
        t.querySelector('.toast-close').addEventListener('click', () => t.remove()); 
        setTimeout(() => t.remove(), 3000); 
    }
    function requestNotificationPermission() { if ('Notification' in window && Notification.permission !== "granted" && Notification.permission !== "denied") { Notification.requestPermission().then(p => { if(p === "granted") showToast('success', 'Notifications Enabled', 'You will receive notifications.'); else { showToast('info', 'Notifications Disabled'); document.getElementById('notifyToggle').checked = false; }}); } else if (Notification.permission === "denied"){ showToast('warning', 'Notifications Blocked', 'Please enable in browser settings.'); document.getElementById('notifyToggle').checked = false; } }
    function showBrowserNotification(title, message) { if ('Notification' in window && Notification.permission === "granted") new Notification(title, { body: message }); }
    function resetTranscriptionUI() {
        generationInProgress = false;
        domCache.loadingOverlay.style.display = 'none';
        domCache.progressContainer.classList.remove('active');
        stopTypewriterAnimation();
        activeProcessingQueue = [];
        currentProcessingIndex = -1;
        isCancelled = false;
        showStatsLoading(false); // Ensure stats loading is reset
        progressBar.style.width = "0%";
        progressPercent.textContent = "0%";
        progressMessage.textContent = "Processing...";
        
        // Reset transcribe button state
        const transcribeButton = document.getElementById("transcribeButton");
        transcribeButton.disabled = false;
        updateTranscribeButtonText();
    }
    function updateProgress(percent, message) { progressBar.style.width = `${percent}%`; progressMessage.textContent = message || 'Processing...'; progressPercent.textContent = `${Math.round(percent)}%`; domCache.progressContainer.classList.toggle('active', percent > 0 && percent < 100); }

    // --- Model & Feature Handling ---
    function handleModelChange() {
        const selectedModel = getSelectedModel();

        // Check if the selected model is one of the OpenAI models
        const isOpenAIModel = ['whisper-1', 'gpt-4o-mini-transcribe', 'gpt-4o-transcribe'].includes(selectedModel);

        // Show/hide API key sections
        apiKeySection.style.display = isOpenAIModel ? 'block' : 'none'; // Shared OpenAI key section
        deepgramApiKeySection.style.display = (selectedModel === 'nova-3') ? 'block' : 'none';
        gladiaApiKeySection.style.display = (selectedModel === 'gladia') ? 'block' : 'none';
        elevenlabsApiKeySection.style.display = (selectedModel === 'scribe-v1') ? 'block' : 'none';
        // Only show Deepgram options if Python backend is available
        isPythonBackendAvailable().then(pythonAvailable => {
          deepgramOptionsDiv.style.display = (selectedModel === 'nova-3' && pythonAvailable) ? 'block' : 'none';
        });

        // Update Model Info highlighting in sidebar - reset all headings first
        if (modelElements.modelInfoSections) {
            modelElements.modelInfoSections.forEach(section => {
                section.classList.remove('active-model');
            });
        }

        // Model highlighting is now handled by the modal when it opens

        updatePriceCalculator(); // Update cost estimate
        handleDeepgramFeatureChange(); // Update visibility of DG tabs based on current checkbox state

        if (currentActiveFile) {
            updateModelCompletionStatus(currentActiveFile); // Update completion badges
            // Check if saved results exist for the *newly selected model* and display them
            const transcription = getFileTranscription(currentActiveFile, selectedModel);
            if (transcription) {
                 console.log(`Switching view to saved results for ${selectedModel} on file ${currentActiveFile}.`);
                 showFileResult(currentActiveFile);
                 // Update stats for the loaded result
                 updateTranscriptionStats(transcription.default_transcript, transcription.elapsed_time);
            } else {
                 // Clear display if no results saved for this model/file combo
                 console.log(`No saved results for ${selectedModel}, clearing transcript display.`);
                 clearTranscriptDisplay(); resetTranscriptionStats();
            }
        } else {
             clearTranscriptDisplay(); resetTranscriptionStats(); // Clear if no file active
             updateModelCompletionStatus(null); // Clear badges if no file active
        }
        updateTranscribeButtonText(); // Ensure button text is correct
    }


    function handleDeepgramFeatureChange(){
         updatePriceCalculator();
         // Check if Deepgram model is currently selected
         const isDeepgramSelected = getSelectedModel() === 'nova-3';

         // Show/hide feature hint messages based on model selection and feature toggles
         document.getElementById('summarizeHint').style.display = isDeepgramSelected && summarizeCheckbox.checked ? 'block' : 'none';
         document.getElementById('topicsHint').style.display = isDeepgramSelected && topicsCheckbox.checked ? 'block' : 'none';

         // In transcript panel:
         // Make Deepgram -specific tabs (Summary, Topics) visible when both conditions are true:
         // 1. Deepgram model is selected
         // 2. The corresponding feature checkbox is checked
         summaryOption.style.display = isDeepgramSelected && summarizeCheckbox.checked ? 'block' : 'none';
         topicsOption.style.display = isDeepgramSelected && topicsCheckbox.checked ? 'block' : 'none';

        // Special case: If we already have processed results for this file with Deepgram,
        // make sure to show the options that have data, regardless of checkbox state
        const currentResults = getCurrentFileResult(currentActiveFile);
        if (currentActiveFile && currentResults?.model === 'nova-3') {
             if(currentResults.summary_text) summaryOption.style.display = 'block';
             if(currentResults.topics_data) topicsOption.style.display = 'block';
        }

         // If the currently active tab was hidden by the changes above,
         // automatically switch to the default transcript tab
         const currentTab = transcriptFormatSelect.value;
         if ((currentTab === 'summary' && summaryOption.style.display === 'none') || 
             (currentTab === 'topics' && topicsOption.style.display === 'none')) {
             switchTab('default');
         }
     }

    function updateModelCompletionStatus(fileId = null) {
        const targetFileId = fileId || currentActiveFile;
        document.querySelectorAll('.model-done-badge').forEach(b => b.remove()); // Clear all first
        const completed = getCompletedModels(targetFileId);
        if (!targetFileId || completed.length === 0) return; // Exit if no data
        document.querySelectorAll('.model-option input[type="radio"]').forEach(radio => {
            if (completed.includes(radio.value)) {
                const label = radio.nextElementSibling;
                if (label && !label.querySelector('.model-done-badge')) { // Ensure badge doesn't exist
                    const badge = document.createElement('span'); badge.className = 'model-done-badge';
                    badge.innerHTML = '<i class="ri-check-line"></i>'; label.appendChild(badge);
                }
            }
        });
    }

    function updateTranscribeButtonText() {
        const selectedFiles = fileQueue.filter(file => file.selected !== false && !file.error);
        const selectedCount = selectedFiles.length;
        const button = document.getElementById("transcribeButton");

        if (generationInProgress) {
            button.innerHTML = `<i class="ri-stop-circle-line"></i><span>Cancel</span>`;
        } else {
            let text = selectedCount > 0 ? (selectedCount > 1 ? `Transcribe Selected (${selectedCount})` : 'Transcribe') : 'Transcribe';
            button.innerHTML = `<i class="ri-draft-line"></i><span>${text}</span>`;
        }
    }

    // --- Price Calculation ---
    function requestPriceCalculatorUpdate() {
        if (priceCalcDebounceId) {
            clearTimeout(priceCalcDebounceId);
        }
        priceCalcDebounceId = setTimeout(() => {
            priceCalcDebounceId = null;
            updatePriceCalculator();
        }, 120);
    }
    function updatePriceCalculator() {
        // Get the price calculator element from cache
        const priceCalculatorDiv = domCache.priceCalculator;
        if (!priceCalculatorDiv) {
            console.error("Price calculator div not found!");
            return;
        }

        const selectedModel = getSelectedModel();
        if (!selectedModel) {
            console.error("No model selected!");
            return;
        }

        const isSummarizeEnabled = selectedModel === 'nova-3' && summarizeCheckbox.checked;
        const isTopicsEnabled = selectedModel === 'nova-3' && topicsCheckbox.checked;

        let baseCostPerMinute = 0; let apiName = ''; let showCalculator = false;
        let totalEstimatedCost = 0; let summarizationCost = 0; let topicDetectionCost = 0; let baseApiCost = 0;

        // Clear any existing attribution notice
        const existingAttribution = document.querySelector('.attribution-notice');
        if (existingAttribution) {
            existingAttribution.remove();
        }
        
        // Add attribution notice for Scribe-v1 if selected
        if (selectedModel === 'scribe-v1') {
            const priceDetails = document.querySelector('.price-details');
            const totalCostRow = document.querySelector('.total-cost-row');
            if (priceDetails && totalCostRow) {
                const attributionRow = document.createElement('div');
                attributionRow.className = 'price-row attribution-notice';
                priceDetails.insertBefore(attributionRow, totalCostRow);
            }
        }

        // Set the pricing documentation link based on the selected model
        const pricingDocLink = document.getElementById('pricingDocLink');
        if (selectedModel === 'whisper-1') { 
            baseCostPerMinute = 0.006; 
            apiName = 'Whisper-1'; 
            showCalculator = true;
            pricingDocLink.href = 'https://platform.openai.com/docs/pricing#transcription-and-speech-generation';
        }
        else if (selectedModel === 'gpt-4o-mini-transcribe') {
            baseCostPerMinute = 0.003;
            apiName = 'GPT-4o Mini';
            showCalculator = true;
            pricingDocLink.href = 'https://platform.openai.com/docs/pricing#audio-models';
        }
        else if (selectedModel === 'gpt-4o-transcribe') {
            baseCostPerMinute = 0.006;
            apiName = 'GPT-4o';
            showCalculator = true;
            pricingDocLink.href = 'https://platform.openai.com/docs/pricing#audio-models';
        }
        else if (selectedModel === 'nova-3') { 
            baseCostPerMinute = 0.0052; 
            apiName = 'Nova-3'; 
            showCalculator = true;
            pricingDocLink.href = 'https://deepgram.com/pricing';
        }
        else if (selectedModel === 'gladia') { 
            apiName = 'Gladia v2';
            showCalculator = true;
            pricingDocLink.href = 'https://docs.gladia.io/chapters/limits-and-specifications/concurrency';
        }
        else if (selectedModel === 'scribe-v1') {
            apiName = 'Scribe v1';
            showCalculator = true;
            pricingDocLink.href = 'https://elevenlabs.io/app/subscription';
        }

        // Force the display property based on showCalculator
        if (priceCalculatorDiv) {
            priceCalculatorDiv.style.display = showCalculator ? 'block' : 'none';
            console.log("Price calculator display:", priceCalculatorDiv.style.display, "for model:", selectedModel);
        } else {
            console.error("Price calculator div not found!");
        }

        summarizationCostRow.style.display = 'none'; topicDetectionCostRow.style.display = 'none'; // Hide feature costs by default
        
        if (showCalculator && currentFileDuration > 0) {
            const durationInMinutes = currentFileDuration / 60;
            
            if (selectedModel === 'gladia') {
                // For Gladia, show hourly credits instead of cost
                fileDurationValue.textContent = formatDuration(currentFileDuration);
                apiPricingLabel.textContent = 'Gladia Free Plan:';
                apiPricingValue.textContent = '10 hours';
                // Calculate file duration in hours (with 2 decimal places)
                const durationInHours = (durationInMinutes / 60).toFixed(2);
                estimatedCostValue.textContent = `${durationInHours} hours`;
            } 
            else if (selectedModel === 'scribe-v1') {
                // For Scribe-v1, show credit usage (0.57 credits/second)
                fileDurationValue.textContent = formatDuration(currentFileDuration);
                apiPricingLabel.textContent = 'Scribe v1 Free Plan:';
                apiPricingValue.textContent = '10,000 credits';
                
                // Calculate estimated credits (0.57 credits/second)
                const estimatedCredits = Math.ceil(currentFileDuration * 0.57);
                estimatedCostValue.textContent = `${estimatedCredits} credits`;
            }
            else {
                // Regular cost calculation for other models
                baseApiCost = durationInMinutes * baseCostPerMinute; 
                totalEstimatedCost += baseApiCost;
                apiPricingLabel.textContent = `${apiName}:`; 
                apiPricingValue.textContent = `$${baseCostPerMinute.toFixed(4)} / min`;

                if (selectedModel === 'nova-3') { // Deepgram feature costs
                    if (isSummarizeEnabled || isTopicsEnabled) {
                        // Calculate estimated number of words in audio
                        const estimatedWords = durationInMinutes * AVG_WORDS_PER_MINUTE;
                        // Calculate estimated input tokens
                        const estimatedInputTokens = estimatedWords * AVG_TOKENS_PER_WORD;
                        
                        if (isSummarizeEnabled) { 
                            // Calculate estimated output tokens for summarization (20% of input)
                            const estimatedSummaryOutputTokens = estimatedInputTokens * SUMMARY_OUTPUT_PERCENTAGE;
                            // Calculate total summarization cost
                            summarizationCost = 
                                (estimatedInputTokens * DEEPGRAM_INPUT_TOKEN_COST) + 
                                (estimatedSummaryOutputTokens * DEEPGRAM_OUTPUT_TOKEN_COST);
                            
                            summarizationCostValue.textContent = `$${summarizationCost.toFixed(4)}`; 
                            summarizationCostRow.style.display = 'flex'; 
                            totalEstimatedCost += summarizationCost; 
                        }
                        
                        if (isTopicsEnabled) { 
                            // Topic detection - input tokens only (minimal output)
                            topicDetectionCost = estimatedInputTokens * DEEPGRAM_INPUT_TOKEN_COST;
                            
                            topicDetectionCostValue.textContent = `$${topicDetectionCost.toFixed(4)}`; 
                            topicDetectionCostRow.style.display = 'flex'; 
                            totalEstimatedCost += topicDetectionCost; 
                        }
                    }
                }
                fileDurationValue.textContent = formatDuration(currentFileDuration); 
                estimatedCostValue.textContent = `$${totalEstimatedCost.toFixed(4)}`;
            }
        } else { // Reset if calculator hidden or no duration
            fileDurationValue.textContent = showCalculator ? 'N/A' : 'N/A';
            if (selectedModel === 'gladia') {
                apiPricingLabel.textContent = `Gladia v2 Free Plan:`;
                apiPricingValue.textContent = '10 hours';
                estimatedCostValue.textContent = '0.00 hours';
            } else if (selectedModel === 'scribe-v1') {
                apiPricingLabel.textContent = `Scribe v1:`;
                apiPricingValue.textContent = '~0.57 credits/second';
                estimatedCostValue.textContent = formatDuration(currentFileDuration);
            } else if (selectedModel === 'whisper-1') {
                apiPricingLabel.textContent = `Whisper-1:`;
                apiPricingValue.textContent = '$0.006 / min';
                estimatedCostValue.textContent = '$0.00';
            } else if (selectedModel === 'gpt-4o-transcribe') {
                apiPricingLabel.textContent = `GPT-4o:`;
                apiPricingValue.textContent = '$0.006 / min';
                estimatedCostValue.textContent = '$0.00';
            } else if (selectedModel === 'gpt-4o-mini-transcribe') {
                apiPricingLabel.textContent = `GPT-4o Mini:`;
                apiPricingValue.textContent = '$0.003 / min';
                estimatedCostValue.textContent = '$0.00';
            } else if (selectedModel === 'nova-3') {
                apiPricingLabel.textContent = `Nova-3:`;
                apiPricingValue.textContent = '$0.0052 / min';
                estimatedCostValue.textContent = '$0.00';
            } else {
                apiPricingLabel.textContent = `${apiName}:`;
                apiPricingValue.textContent = 'N/A';
                estimatedCostValue.textContent = '$0.00';
                
                // Show simplified token pricing for Deepgram AI features
                // Combined from $0.0003/1k input tokens + $0.0006/1k output tokens
                if (selectedModel === 'nova-3') {
                    if (isSummarizeEnabled) {
                        summarizationCostRow.style.display = 'flex';
                        summarizationCostValue.textContent = '$0.0009/1k tokens';
                    }
                    
                    if (isTopicsEnabled) {
                        topicDetectionCostRow.style.display = 'flex';
                        topicDetectionCostValue.textContent = '$0.0009/1k tokens';
                    }
                }
            }
        }

        // Ensure the calculator actually shows up
        if (showCalculator) {
            // Force display to block and ensure it's visible
            priceCalculatorDiv.style.display = 'block';
            priceCalculatorDiv.style.visibility = 'visible';
            console.log("Price calculator should now be visible:", selectedModel);
        } else {
            priceCalculatorDiv.style.display = 'none';
        }
    }
    
    function formatDuration(seconds) { if (isNaN(seconds) || seconds <= 0) return "0:00"; const m = Math.floor(seconds / 60); const s = Math.floor(seconds % 60); return `${m}:${s.toString().padStart(2, '0')}`; }

    // --- Formatting & Misc ---
    function formatTopics(topicsData) { if (!topicsData?.segments?.length) return '<p><i>No topics detected.</i></p>'; const uniqueTopics = new Set(); topicsData.segments.forEach(seg => seg.topics?.forEach(t => uniqueTopics.add(t.topic))); if (uniqueTopics.size === 0) return '<p><i>No specific topics identified.</i></p>'; let html = '<div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">'; uniqueTopics.forEach(topic => { html += `<span class="topic-tag">${topic}</span>`; }); html += '</div>'; return html; }
    const languages = { latin: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', cyrillic: '', japanese: '', korean: '', chinese: '', arabic: '', devanagari: '' }; // For typewriter
    function formatTimeForDisplay(seconds) { if (isNaN(seconds) || seconds < 0) return "0:00"; const totalSeconds = Math.floor(seconds); const minutes = Math.floor(totalSeconds / 60); const secs = totalSeconds % 60; return `${minutes}:${secs.toString().padStart(2, '0')}`; } // Local JS time formatter for UI display

    // Get consistent waveform colors
    function getWaveformColors() {
        return {
            waveColor: getComputedStyle(document.body).getPropertyValue('--text-tertiary').trim(),
            progressColor: getComputedStyle(document.body).getPropertyValue('--primary-color').trim()
        };
    }
    
    // Add completely new implementation of applyTheme that properly rebuilds waveforms
    function applyTheme(themeName) {
        // Clear the waveform container first to prevent them from stacking
        const waveformEl = document.getElementById('waveform');
        if (waveformEl) {
            // Recreate the time display element with default 0:00 values
            // This ensures we don't see stale timestamps when changing themes
            waveformEl.innerHTML = '';
            const timeDisplay = document.createElement('div');
            timeDisplay.className = 'time-display';
            timeDisplay.innerHTML = '<span class="time-left">0:00</span><span class="time-center"></span><span class="time-right">0:00</span>';
            waveformEl.appendChild(timeDisplay);
        }
        
        // Properly destroy any existing wavesurfer instances
        if (wavesurfer) {
            try {
                wavesurfer.pause();
                wavesurfer.destroy();
                wavesurfer = null;
            } catch(e) { console.warn("Error destroying wavesurfer:", e); }
        }
        
        if (videoWavesurfer) {
            try {
                videoWavesurfer.pause();
                videoWavesurfer.destroy();
                videoWavesurfer = null;
            } catch(e) { console.warn("Error destroying videoWavesurfer:", e); }
        }
        
        // Apply theme changes
        document.body.classList.remove('Toffee-theme', 'minty-theme', 'nova-theme');
        if (themeName !== 'light') document.body.classList.add(`${themeName}-theme`);

        // Update active state for all theme buttons
        document.querySelectorAll('input[name="theme_option"]').forEach(radio => {
            radio.checked = (radio.value === themeName);
        });

        // Save state for audio/video
        const audioURL = currentPreviewedFile?.objectURL;
        
        // Recreate waveform if needed with a slight delay to ensure DOM is updated
        setTimeout(() => {
            if (currentPreviewedFile && audioURL) {
                if (currentPreviewedFile.type.startsWith('audio/')) {
                    // Reinitialize audio wavesurfer
                    const colors = getWaveformColors();
                    wavesurfer = WaveSurfer.create({ 
                        container: '#waveform', 
                        waveColor: colors.waveColor, 
                        progressColor: colors.progressColor, 
                        height: 60, responsive: true, 
                        backend: 'MediaElement', 
                        mediaControls: false, 
                        normalize: true, 
                        partialRender: true 
                    });
                    
                    wavesurfer.isReady = false;
                    wavesurfer.load(audioURL);
                    wavesurfer.on('ready', () => { 
                        wavesurfer.isReady = true;
                        currentFileDuration = wavesurfer.getDuration() || 0;
                        document.querySelector(".time-right").textContent = formatTimeForDisplay(currentFileDuration);
                        document.querySelector(".time-left").textContent = "0:00";
                        setupPlayerEventHandlers();
                        attachSyncToPlayer();
                    });
                }
                else if (currentPreviewedFile.type.startsWith('video/')) {
                    // Reinitialize video waveform
                    initializeVideoWaveform(audioURL);
                    // Ensure proper event handlers for video waveform
                    videoWavesurfer.on('ready', () => {
                        videoWavesurfer.isReady = true;
                        currentFileDuration = videoWavesurfer.getDuration() || 0;
                        document.querySelector(".time-right").textContent = formatTimeForDisplay(currentFileDuration);
                        document.querySelector(".time-left").textContent = "0:00";
                        attachSyncToPlayer();
                        setupPlayerEventHandlers();
                    });
                }
            }

            // Reset the theme change flag once processing is complete
            themeChangeInProgress = false;
        }, 100);
    }

    let themeChangeInProgress = false; // Flag to track theme change status

    function switchTheme(themeName) { 
        // Skip if same theme change is already in progress
        if (themeChangeInProgress) return;
        
        themeChangeInProgress = true; // Set flag
        applyTheme(themeName); 
        localStorage.setItem('theme', themeName); 
    }
    
    
    // --- Model Selection ---
    function handleModelSelection() {
        const selectedModel = getSelectedModel();
        if (!selectedModel) return;
        console.log(`Selected model: ${selectedModel}`);
        
        // Auto-switch to appropriate tab based on selected model (only when server available for local models)
        const isLocalModel = ['tiny', 'base', 'small', 'medium', 'large', 'large-v2', 'large-v3', 'turbo'].includes(selectedModel);
        const isCloudModel = ['whisper-1', 'gpt-4o-transcribe', 'gpt-4o-mini-transcribe', 'nova-3', 'gladia', 'scribe-v1'].includes(selectedModel);
        
        if (isLocalModel && serverAvailable) {
          switchModelTab('local');
        } else if (isCloudModel) {
          switchModelTab('cloud');
        }

        
        // Update API sections visibility
        updateApiSectionsVisibility();
        
        updatePriceCalculator();

        if (currentActiveFile) {
            updateModelCompletionStatus(currentActiveFile); // Update completion badges first

            // Check if saved results exist for the *newly selected model* and display them
            const transcription = getFileTranscription(currentActiveFile, selectedModel);
            if (transcription) {
                 console.log(`Switching view to saved results for ${selectedModel} on file ${currentActiveFile}.`);
                 showFileResult(currentActiveFile);
                 // Update stats for the loaded result
                 updateTranscriptionStats(transcription.default_transcript, transcription.elapsed_time);
            } else {
                 // Clear display if no results saved for this model/file combo
                 console.log(`No saved results for ${selectedModel}, clearing transcript display.`);
                 clearTranscriptDisplay(); resetTranscriptionStats();
            }
        } else {
             clearTranscriptDisplay(); resetTranscriptionStats(); // Clear if no file active
             updateModelCompletionStatus(null); // Clear badges if no file active
        }

        // Update Model Info highlighting in sidebar - reset all headings first
        if (modelElements.modelInfoSections) {
            modelElements.modelInfoSections.forEach(section => {
                section.classList.remove('active-model');
            });
        }
        // Model highlighting is now handled by the modal when it opens

        updatePriceCalculator();
        updateTranscribeButtonText(); // Ensure button text is correct after model change
    }

    // Centralized Model Icon System
    const MODEL_ICONS = {
        // Local Models (Whisper)
        'tiny': 'ri-speed-mini-line',
        'base': 'ri-scales-line',
        'small': 'ri-speed-up-line',
        'medium': 'ri-focus-3-line',
        'turbo': 'ri-rocket-line',
        'large': 'ri-cpu-line',
        
        // Cloud Models
        'whisper-1': 'ri-openai-fill',
        'gpt-4o-mini-transcribe': 'ri-openai-fill',
        'gpt-4o-transcribe': 'ri-openai-fill',
        'nova-3': 'custom-svg-deepgram',
        'gladia': 'ri-voiceprint-fill',
        'scribe-v1': 'custom-svg-elevenlabs'
    };

    const CUSTOM_SVGS = {
        'deepgram': '<svg class="model-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="30" viewBox="0 0 24 24"><path fill="currentColor" d="M11.203 24H1.517a.364.364 0 0 1-.258-.62l6.239-6.275a.37.37 0 0 1 .259-.108h3.52c2.723 0 5.025-2.127 5.107-4.845a5.004 5.004 0 0 0-4.999-5.148H7.613v4.646c0 .2-.164.364-.365.364H.968a.365.365 0 0 1-.363-.364V.364C.605.164.768 0 .969 0h10.416c6.684 0 12.111 5.485 12.01 12.187C23.293 18.77 17.794 24 11.202 24z"/></svg>',
        'elevenlabs': '<svg class="model-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="30" viewBox="0 0 300 400"><path fill="currentColor" d="M60 55H120V345H60Z M190 55H250V345H190Z"/></svg>'
    };

    /**
     * Generate model icon HTML for a given model
     * @param {string} modelId - The model identifier
     * @param {string} additionalClasses - Additional CSS classes to add
     * @returns {string} HTML string for the model icon
     */
    function getModelIcon(modelId, additionalClasses = '') {
        const iconClass = MODEL_ICONS[modelId];
        
        if (!iconClass) {
            console.warn(`No icon found for model: ${modelId}`);
            return '<i class="ri-question-line model-icon"></i>';
        }
        
        if (iconClass === 'custom-svg-deepgram') {
            return CUSTOM_SVGS.deepgram;
        } else if (iconClass === 'custom-svg-elevenlabs') {
            return CUSTOM_SVGS.elevenlabs;
        } else {
            const classes = `${iconClass} model-icon ${additionalClasses}`.trim();
            return `<i class="${classes}"></i>`;
        }
    }

    /**
     * Initialize model icons by populating them with actual icon content
     */
    function initializeModelIcons() {
        // Handle all model icons (both settings and modal)
        const modelIcons = document.querySelectorAll('.model-icon[data-model]');
        modelIcons.forEach(icon => {
            const modelId = icon.getAttribute('data-model');
            if (modelId) {
                icon.outerHTML = getModelIcon(modelId);
            }
        });
    }

    // Model Info Modal functionality
    function openModelInfoModal() {
        const modal = document.getElementById('modelInfoModal');
        modal.style.display = 'flex';
        
        document.body.style.overflow = 'hidden';
    }

    function closeModelInfoModal() {
        const modal = document.getElementById('modelInfoModal');
        modal.style.display = 'none';
        
        document.body.style.overflow = '';
    }

    // Event listeners for modal
    document.addEventListener('DOMContentLoaded', function() {
        // Question button click
        const questionButton = document.querySelector('.settings-title .btn-icon');
        if (questionButton) {
            questionButton.addEventListener('click', openModelInfoModal);
        }

        // Close button click
        const closeButton = document.querySelector('.modal-close');
        if (closeButton) {
            closeButton.addEventListener('click', closeModelInfoModal);
        }

        // Click outside modal to close
        const modalOverlay = document.getElementById('modelInfoModal');
        if (modalOverlay) {
            modalOverlay.addEventListener('click', function(e) {
                if (e.target === modalOverlay) {
                    closeModelInfoModal();
                }
            });
        }

        // Escape key to close
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('modelInfoModal');
                if (modal.style.display === 'flex') {
                    closeModelInfoModal();
                }
            }
        });
    });
    
  </script>

  <!-- Model Info Modal -->
  <div id="modelInfoModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2><i class="ri-information-line"></i> Model Information</h2>
        <button class="btn btn-icon modal-close" title="Close">
          <i class="ri-close-line"></i>
        </button>
      </div>
      <div class="modal-body">
        <!-- Local Models Section (First) -->
        <div class="models-section">
          <h2>Local Models (Whisper)</h2>
          <div class="models-grid">
            <div class="model-card">
              <h3 data-model="tiny"><span class="model-icon" data-model="tiny"></span> Tiny</h3>
              <ul>
                <li>Fastest, but least accurate.</li>
                <li>VRAM req. ~1 GB</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="base"><span class="model-icon" data-model="base"></span> Base</h3>
              <ul>
                <li>Enhanced accuracy over Tiny.</li>
                <li>VRAM req. ~1 GB</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="small"><span class="model-icon" data-model="small"></span> Small</h3>
              <ul>
                <li>Balanced speed and performance.</li>
                <li>VRAM req. ~2 GB</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="medium"><span class="model-icon" data-model="medium"></span> Medium</h3>
              <ul>
                <li>Improved nuance and accent handling.</li>
                <li>VRAM req. ~4 GB</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="turbo"><span class="model-icon" data-model="turbo"></span> Turbo</h3>
              <ul>
                <li>Second best quality.</li>
                <li>VRAM req. ~6 GB</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="large"><span class="model-icon" data-model="large"></span> Large</h3>
              <ul>
                <li>Best quality, but very slow. A regular computer may struggle to run this.</li>
                <li>VRAM req. ~10 GB</li>
              </ul>
            </div>
          </div>
          
          <div class="info-section" style="margin-top: 1rem;">
            <p>Whisper is OpenAI's open-source general-purpose speech recognition model. The available local models offer tradeoffs between transcription accuracy and processing speed. For an in-depth overview, refer to the <a href="https://github.com/openai/whisper" target="_blank"><i class="ri-external-link-line"></i> Whisper Documentation</a>.</p>
          </div>
        </div>

        <!-- Cloud Models Section (Second) -->
        <div class="models-section">
          <h2>Cloud Models</h2>
          <div class="models-grid">
            <div class="model-card">
              <h3 data-model="whisper-1"><span class="model-icon" data-model="whisper-1"></span> Whisper-1<i class="ri-external-link-line" title="Whisper Cloud Documentation" onclick="window.open('https://platform.openai.com/docs/guides/speech-to-text', '_blank');"></i></h3>
              <ul>
                <li>OpenAI's original cloud transcription model, still good and cheap. Supports native timestamps.</li>
                <li>Offers $5 free (API) credits (~14 hours of transcription).</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="gpt-4o-mini-transcribe"><span class="model-icon" data-model="gpt-4o-mini-transcribe"></span> 4o Mini<i class="ri-external-link-line" title="OpenAI Audio Models Documentation" onclick="window.open('https://platform.openai.com/docs/guides/speech-to-text', '_blank');"></i></h3>
              <ul>
                <li>Uses GPT-4o mini to transcribe audio. Supports prompting. Does not support native timestamps.</li>
                <li>Half the price of 4o.</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="gpt-4o-transcribe"><span class="model-icon" data-model="gpt-4o-transcribe"></span> 4o<i class="ri-external-link-line" title="OpenAI Audio Models Documentation" onclick="window.open('https://platform.openai.com/docs/guides/speech-to-text', '_blank');"></i></h3>
              <ul>
                <li>Uses GPT-4o to transcribe audio. Supports prompting. Does not support native timestamps.</li>
                <li>Most expensive model.</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="nova-3"><span class="model-icon" data-model="nova-3"></span> Nova-3<i class="ri-external-link-line" title="Nova-3 Documentation" onclick="window.open('https://developers.deepgram.com/docs/models-languages-overview', '_blank');"></i></h3>
              <ul>
                <li>Deepgram's cloud model with multi-language support. Offers advanced AI features like summarization and topic detection for English content.</li>
                <li>Offers $200 free (API) credits (~640 hours of transcription).</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="gladia"><span class="model-icon" data-model="gladia"></span> Gladia v2<i class="ri-external-link-line" title="Gladia Documentation" onclick="window.open('https://docs.gladia.io/chapters/introduction/introduction', '_blank');"></i></h3>
              <ul>
                <li>Gladia with automatic language detection and multi-language support.</li>
                <li>Offers 10 hours of free (API) credits per month.</li>
              </ul>
            </div>

            <div class="model-card">
              <h3 data-model="scribe-v1"><span class="model-icon" data-model="scribe-v1"></span> Scribe-v1<i class="ri-external-link-line" title="Scribe v1 Documentation" onclick="window.open('https://elevenlabs.io/docs/models#scribe-v1', '_blank');"></i></h3>
              <ul>
                <li>ElevenLabs' speech-to-text model supporting 99 languages.</li>
                <li>Offers 10,000 free (API) credits per month (~4,87 hours of transcription).</li>
                <li style="font-style: italic;">Free tier <a href="https://elevenlabs.io/pricing#pricing-table" target="_blank" style="color: var(--primary-color);">requires attribution</a> and does not have commercial licensing.</li>
              </ul>
            </div>
          </div>
        </div>

        <!-- API Setup Section (Last) -->
        <div class="models-section">
          <div class="api-setup-unified">
            <h3><i class="ri-key-2-line"></i> API Setup Guide</h3>
            <div class="api-providers">
              <div class="api-provider">
                <h4><i class="ri-openai-fill"></i> OpenAI (Whisper-1, 4o Mini, 4o)</h4>
                <ol>
                  <li>Go to <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com/api-keys</a></li>
                  <li>Create account or sign in</li>
                  <li>Click "+ Create new secret key"</li>
                  <li>Copy key and paste in settings</li>
                </ol>
              </div>
              
              <div class="api-provider">
                <h4><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24"><path fill="currentColor" d="M11.203 24H1.517a.364.364 0 0 1-.258-.62l6.239-6.275a.37.37 0 0 1 .259-.108h3.52c2.723 0 5.025-2.127 5.107-4.845a5.004 5.004 0 0 0-4.999-5.148H7.613v4.646c0 .2-.164.364-.365.364H.968a.365.365 0 0 1-.363-.364V.364C.605.164.768 0 .969 0h10.416c6.684 0 12.111 5.485 12.01 12.187C23.293 18.77 17.794 24 11.202 24z"/></svg> Deepgram (Nova-3)</h4>
                <ol>
                  <li>Go to <a href="https://console.deepgram.com/signup" target="_blank">console.deepgram.com</a></li>
                  <li>Create account or sign in</li>
                  <li>Navigate to "API Keys" section</li>
                  <li>Click "Create a New API Key"</li>
                  <li>Copy key and paste in settings</li>
                </ol>
              </div>
              
              <div class="api-provider">
                <h4><i class="ri-voiceprint-fill"></i> Gladia (Gladia v2)</h4>
                <ol>
                  <li>Go to <a href="https://app.gladia.io/register" target="_blank">app.gladia.io</a></li>
                  <li>Create account or sign in</li>
                  <li>Navigate to "API keys" in settings</li>
                  <li>Click "Generate new key"</li>
                  <li>Copy key and paste in settings</li>
                </ol>
              </div>
              
              <div class="api-provider">
                <h4><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 300 400"><path fill="currentColor" d="M60 55H120V345H60Z M190 55H250V345H190Z"/></svg> ElevenLabs (Scribe-v1)</h4>
                <ol>
                  <li>Go to <a href="https://elevenlabs.io/" target="_blank">elevenlabs.io</a></li>
                  <li>Sign up or log in</li>
                  <li>Select "API + API KEYS" in navigation</li>
                  <li>Create API Key</li>
                  <li>Copy key and paste in settings</li>
                </ol>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

</body>
</html>